<!doctype html><html lang=en-us><head><script>location.host!=new URL("https://lorenzozaccagnini.github.io").host&&(location.href="https://lorenzozaccagnini.github.io")</script><meta name=viewport content="width=device-width"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=7"><link rel=icon href=/favicon.png><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon href=/apple-touch-icon.png><link rel=icon href=/logo.svg type=image/svg+xml><title>Develop an Ethereum oracle with Rust &ndash;
Thorrwulf</title><link href=/symbols-nerd-font/symbols-nerd-font.css rel=stylesheet><link href=/jetbrains-mono/jetbrains-mono.css rel=stylesheet><link type=text/css rel=stylesheet href=https://lorenzozaccagnini.github.io/css/styles.0923ee2caa2b176e7020d86ed9cdd6c352d8aa9c06d62c8bd86eb181761fdff490effa74adbc248de8ae6f5ae749a937c3755ecdf8774dcc52555e2008922beb.css integrity="sha512-CSPuLKorF25wINhu2c3Ww1LYqpwG1iyL2G6xgXYf3/SQ7/p0rbwkjeiub1rnSak3w3Vezfh3TcxSVV4gCJIr6w=="><meta name=author content="Lorenzo Zaccagnini"><meta name=keywords content="alchemy,blockchain,infura,oracle,rust,web3"><meta name=description content="s a service that allows smart contracts to interact with external data sources. In this post, we will develop a simple oracle that will track everytime a Ethereum Name Service NFT is transferred. We will use Rust and the web3 crate to interact with the Ethereum blockchain.
1. Why blockchains can&amp;rsquo;t access external data sources Blockchains can&amp;rsquo;t access external data sources natively because it is a deterministic system."><meta property="og:site_name" content="Thorrwulf"><meta property="og:title" content="Develop an Ethereum oracle with Rust"><meta property="og:type" content="article"><meta property="article:author" content="Lorenzo Zaccagnini"><meta property="article:published_time" content="2022-10-22T00:03:47Z+0200"><meta property="article:tag" content="alchemy"><meta property="article:tag" content="blockchain"><meta property="article:tag" content="infura"><meta property="article:tag" content="oracle"><meta property="article:tag" content="rust"><meta property="article:tag" content="web3"><meta property="og:url" content="https://lorenzozaccagnini.github.io/posts/simple-rust-oracle/"><meta property="og:image" content="https://lorenzozaccagnini.github.io/images/post_pics/oraclecover.jpg
        "><meta property="og:description" content="A blockhain oracle is a service that allows smart contracts to interact with external data sources. In this post, we will develop a simple oracle that will trac"><meta name=twitter:card content="summary_large_image"><meta property="twitter:domain" content="lorenzozaccagnini.github.io"><meta property="twitter:url" content="https://lorenzozaccagnini.github.io/posts/simple-rust-oracle/"><meta name=twitter:title content="Develop an Ethereum oracle with Rust"><meta name=twitter:image content="https://lorenzozaccagnini.github.io/images/post_pics/oraclecover.jpg
        "><meta name=twitter:description content="A blockhain oracle is a service that allows smart contracts to interact with external data sources. In this post, we will develop a simple oracle that will trac"><link rel=manifest href=/manifest/index.json></head><body><div id=baseContainer><header><div class=titleAndSearchContainer><div id=titleContainer><a class=unstyledLink href=/><img src=/logo.svg></a><div class=rightOfLogo><div class=titleAndHamburger><h1><a class=unstyledLink href=/>Thorrwulf</a></h1></div><div id=wide_nav><nav><ul id=main-nav><li><a href=/>Home</a></li><li><a href=/posts>Posts</a></li><li><a href=https://lorenzozaccagnini.github.io/pages/about/>About</a></li><li><a href=/tags>Tags</a></li></ul></nav></div></div></div><div class=search><input id=searchbar type=text placeholder=Search>
<a class=nerdlink onclick=newSearch()>&#xf002;</a></div><script>function newSearch(){let e=searchbar.value.trim();if(!e)return;location.href=`/search?q=${e}`}searchbar.onkeyup=e=>{e.keyCode==13&&newSearch()}</script></div><div id=links><a rel=noreferrer target=_blank class=nerdlink href=/index.xml>&#xf09e;
<span>RSS</span></a>
<a rel=noreferrer target=_blank class=nerdlink href=https://github.com/LorenzoZaccagnini>&#xf09b;
<span>Github</span></a>
<a rel=noreferrer target=_blank class=nerdlink href=https://www.youtube.com/channel/UCG3x5s-ozMUr0uXv4d8mP-g>&#xf16a;
<span>YouTube</span></a></div></header><div id=contentContainer><div id=content><main><article class="card single"><h1>Develop an Ethereum oracle with Rust</h1><p class=date><span title=Date></span>
2022-10-22</p><figure style=margin:0><img src=/images/post_pics/oraclecover.jpg alt></figure><div><p>A blockhain oracle is a service that allows smart contracts to interact with external data sources. In this post, we will develop a simple oracle that will track everytime a <a href=https://etherscan.io/address/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85>Ethereum Name Service NFT</a> is transferred. We will use Rust and the web3 crate to interact with the Ethereum blockchain.</p><h2 id=1-why-blockchains-cant-access-external-data-sources>1. Why blockchains can&rsquo;t access external data sources</h2><p>Blockchains can&rsquo;t access external data sources natively because it is a deterministic system. Each node in the network has a copy of the blockchain, they must all agree on the same state. If a smart contract was able to access external data sources, it would break the deterministic nature of the blockchain. The verification of the state of the blockchain would be impossible, remember same inputs always produce the same outputs.</p><p>We can solve this problem by using a blockchain oracle. A blockchain oracle is a service that allows smart contracts to interact with external data sources. The oracle will be responsible for fetching the external data and sending it to the smart contract. The smart contract will then be able to access the data.</p><p>Let&rsquo;s make an example to illustrate this. Let&rsquo;s say we have a smart contract that stores the current price of a cryptocurrency. If the price of the cryptocurrency is updated every 10 seconds on an external API, the smart contract will have to be updated every 10 seconds, otherwise the smart contract will be out of sync. It would impossible for others to verify the state of the blockchain.</p><p>This is why blockchains need oracles, external data must be fed into the blockchain with a transaction, in this way all nodes in the network will have the same data and the blockchain will remain deterministic.</p><p><a href=https://ethereum.stackexchange.com/questions/301/why-cant-contracts-make-api-calls>Read this fantastic answer on stackoverflow to learn more about that</a></p><p>In my experience I&rsquo;ve developed many blockchain oracles, for our project Devoleum and for many other projects. I&rsquo;ve used different langauges but Rust is the one that I love the most. I&rsquo;ve developed oracles for various use cases:</p><ul><li>Crosschain bridges</li><li>Connecting IoT to the Ethereum blockchain</li><li>Display data from the blockchain for a frontend that does not have access to the blockchain via a browser wallet like metamask.</li></ul><h2 id=2-what-is-an-oracle>2. What is an oracle?</h2><p>Most of the time is a simple service that listens to events on the blockchain and updates the state of the smart contract. It can also be a smart contract that is called by other smart contracts to get external data. In this article we will develop a simple service that will listen to events on the ethereum blockchain, more precisely the transfer event of ENS NFTs.</p><p>Different types of oracles exist, some of them are:</p><ul><li><strong>Inbound oracles</strong>: they listen to events on the blockchain</li><li><strong>Outbound oracles</strong>: they send transactions to the blockchain</li><li><strong>Hybrid oracles</strong>: they listen to events on the blockchain and send transactions to the blockchain</li></ul><h2 id=3-setup-the-ethereum-oracle-project>3. Setup the ethereum oracle project</h2><p>We will develop a simple oracle that will listen to the transfer event of ENS NFTs. We will use Rust and the web3 crate to interact with the Ethereum blockchain. We will use the Alchemy API to interact with the Ethereum blockchain, otherwise it will be necessary to run a full node.</p><p>All the code of this article is available on <a href=https://github.com/LorenzoZaccagnini/simple-rust-ethereum-inbound-oracle>Github</a>.</p><h3 id=31-install-rust>3.1. Install Rust</h3><p>If you don&rsquo;t have Rust installed on your machine, you can follow the <a href=https://www.rust-lang.org/tools/install>official installation guide</a>.</p><h3 id=32-create-a-new-project>3.2. Create a new project</h3><p>We will use the cargo command to create a new project. Cargo is the Rust package manager and build system.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cargo new simple-rust-oracle
</span></span></code></pre></div><h3 id=33-add-the-dependencies>3.3. Add the dependencies</h3><p>We will add the web3 and other dependencies to our <strong>Cargo.toml</strong> file:</p><ul><li><strong>Web3</strong> crate is a Rust library for interacting with Ethereum and other blockchain nodes. It provides a full set of features for interacting with the blockchain, including sending transactions, reading data from the blockchain, and listening to events.</li><li><strong>Tokio</strong> is a runtime for asynchronous Rust applications.</li><li>The <strong>dotenv</strong> crate is used to load environment variables from a .env file, we&rsquo;ll use it to load our Alchemy API key without hardcoding it in our code (and exposing it to the world).</li><li><strong>Ethnum</strong> is used to handle big unsigned integers.</li></ul><p>This how our <strong>Cargo.toml</strong> file should look like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-toml data-lang=toml><span style=display:flex><span>[dependencies]
</span></span><span style=display:flex><span>web3 = <span style=color:#f1fa8c>&#34;0.17.0&#34;</span>
</span></span><span style=display:flex><span>tokio = { version= <span style=color:#f1fa8c>&#34;1&#34;</span>, features = [<span style=color:#f1fa8c>&#34;full&#34;</span>] }
</span></span><span style=display:flex><span>dotenv = <span style=color:#f1fa8c>&#34;0.15.0&#34;</span>
</span></span><span style=display:flex><span>ethnum = <span style=color:#f1fa8c>&#34;1.3.0&#34;</span>
</span></span></code></pre></div><h3 id=34-create-a-env-file>3.4. Create a .env file</h3><p>We will create a .env file in the root of our project. We will store our <a href=https://www.alchemy.com/>Alchemy API key</a> in this file and load it with the dotenv crate.</p><p>You can use <a href=https://infura.io/>Infura</a> instead of Alchemy, just replace the Alchemy API key with your Infura API key.</p><p>In both cases you have to signup to get an API key. <strong>I will use the mainnet API key</strong> to listen to the ENS NFTs transfer events. You can use the testnet API key if you want to test the oracle on the testnet.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>touch .env
</span></span></code></pre></div><p>The .env file should look like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>ALCHEMY_API_KEY</span><span style=color:#ff79c6>=</span>wss://eth-mainnet.g.alchemy.com/v2/S0meR4nd0mStr1ng
</span></span></code></pre></div><h2 id=4-develop-the-ethereum-oracle>4. Develop the ethereum oracle</h2><h3 id=41-load-the-environment-variables>4.1. Load the environment variables</h3><p>We will load the environment variables with the dotenv crate. We will use the <strong>dotenv::dotenv()</strong> function to load the environment variables from the .env file. We will use the <strong>dotenv::var()</strong> function to get the value of a specific environment variable.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> dotenv::dotenv;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    dotenv().ok();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> alchemy_api_key <span style=color:#ff79c6>=</span> dotenv::var(<span style=color:#f1fa8c>&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style=color:#f1fa8c>&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=42-connect-to-the-ethereum-blockchain>4.2. Connect to the Ethereum blockchain</h3><p>We will use the web3 crate and the Alchemy API to connect to the Ethereum blockchain.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>use</span> dotenv::dotenv;
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> web3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() {
</span></span><span style=display:flex><span>    dotenv().ok();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> alchemy_api_key <span style=color:#ff79c6>=</span> dotenv::var(<span style=color:#f1fa8c>&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style=color:#f1fa8c>&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> web3 <span style=color:#ff79c6>=</span> web3::Web3::new(web3::transports::Http::new(<span style=color:#ff79c6>&amp;</span>alchemy_api_key).unwrap());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=43-filter-to-the-ens-nfts-transfer-events>4.3. Filter to the ENS NFTs transfer events</h3><p>We need to know the ENS smartcontract address to listen to the transfer events. We can find the address of the ENS smartcontract on <a href=https://etherscan.io/address/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85#code>Etherscan</a>.</p><p><strong>WAIT!</strong> We want to listen to a specific event, no to every event of the smart contract so we need to know the event signature. The event signature is the hash of the event name and the event parameters.</p><p>Signature or topic0 = 0x + keccak256(&ldquo;Transfer(address,address,uint256)&rdquo;))</p><p>0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef = Transfer(address,address,uint256)</p><p>As you can see here on <a href=https://etherscan.io/address/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85#events>Etherscan</a> the event signature is 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.</p><p><img src=/images/post_pics/simple_rust_oracle/eventetherscan.jpg alt></p><p>Let&rsquo;s code it!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>use</span> dotenv::dotenv;
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> web3;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() -&gt; <span style=color:#8be9fd;font-style:italic>Result</span><span style=color:#ff79c6>&lt;</span>(), <span style=color:#8be9fd;font-style:italic>Box</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>dyn</span> std::error::Error<span style=color:#ff79c6>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    dotenv().ok();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> alchemy_api_key <span style=color:#ff79c6>=</span> dotenv::var(<span style=color:#f1fa8c>&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style=color:#f1fa8c>&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> web3 <span style=color:#ff79c6>=</span> web3::Web3::new(web3::transports::WebSocket::new(<span style=color:#ff79c6>&amp;</span>alchemy_api_key).<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> contract_address <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> event_signature <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> filter <span style=color:#ff79c6>=</span> web3::types::FilterBuilder::default()
</span></span><span style=display:flex><span>        .address(vec![contract_address.parse().unwrap()])
</span></span><span style=display:flex><span>        .from_block(web3::types::BlockNumber::Latest)
</span></span><span style=display:flex><span>        .topics(
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>Some</span>(vec![event_signature.parse().unwrap()]),
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>None</span>,
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>None</span>,
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>None</span>,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>Ok</span>(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As you can read I set the contract address and the event signature. I also wrote the filter to listen to the latest block. The filter contains the contract address and the event signature. Note that I&rsquo;ve used the <strong>topics</strong> function to filter to the specific event and Tokio to run the code asynchronously.</p><h3 id=44-listen-and-print-the-ethereum-ens-transfer-events>4.4. Listen and print the Ethereum ENS transfer events</h3><p>Now we need to subscribe to the filter and listen to the events. We will use the <strong>web3.eth_subscribe()</strong> function to subscribe to the filter. We will use the <strong>web3::types::Log</strong> struct to decode the event data.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>use</span> dotenv::dotenv;
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> web3;
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> web3::futures::{future, StreamExt};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() -&gt; <span style=color:#8be9fd;font-style:italic>Result</span><span style=color:#ff79c6>&lt;</span>(), <span style=color:#8be9fd;font-style:italic>Box</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>dyn</span> std::error::Error<span style=color:#ff79c6>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    dotenv().ok();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> alchemy_api_key <span style=color:#ff79c6>=</span> dotenv::var(<span style=color:#f1fa8c>&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style=color:#f1fa8c>&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> web3 <span style=color:#ff79c6>=</span> web3::Web3::new(web3::transports::WebSocket::new(<span style=color:#ff79c6>&amp;</span>alchemy_api_key).<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> contract_address <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> event_signature <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> filter <span style=color:#ff79c6>=</span> web3::types::FilterBuilder::default()
</span></span><span style=display:flex><span>        .address(vec![contract_address.parse().unwrap()])
</span></span><span style=display:flex><span>        .from_block(web3::types::BlockNumber::Latest)
</span></span><span style=display:flex><span>        .topics(
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>Some</span>(vec![event_signature.parse().unwrap()]),
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>None</span>,
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>None</span>,
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>None</span>,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> transfer_listen <span style=color:#ff79c6>=</span> web3.eth_subscribe().subscribe_logs(filter).<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transfer_listen
</span></span><span style=display:flex><span>        .for_each(<span style=color:#ff79c6>|</span>log<span style=color:#ff79c6>|</span> {
</span></span><span style=display:flex><span>            println!(<span style=color:#f1fa8c>&#34;log: {:?}&#34;</span>, log);
</span></span><span style=display:flex><span>            future::ready(())
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .<span style=color:#ff79c6>await</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>Ok</span>(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>I&rsquo;ve used <strong>future::ready</strong> to run the code asynchronously. I&rsquo;ve also used the <strong>for_each</strong> function to iterate over the events.</p><p><strong>The result should be this:</strong></p><p><img src=/images/post_pics/simple_rust_oracle/transferlog.jpg alt></p><h3 id=45-decode-the-event-data>4.5. Decode the event data</h3><p>We need to decode the event data to get the transfer details. First we import ethnum, after we decode the event data in the <strong>transfer_listen</strong> loop. We get the hex string of token id from the fourth topic, after I use <strong>from_str_radix()</strong> from <strong>ethnum</strong> to convert the hex string to a U256.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ff79c6>use</span> dotenv::dotenv;
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> ethnum::U256;
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> web3;
</span></span><span style=display:flex><span><span style=color:#ff79c6>use</span> web3::futures::{future, StreamExt};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>#[tokio::main]</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>async</span> <span style=color:#ff79c6>fn</span> <span style=color:#50fa7b>main</span>() -&gt; <span style=color:#8be9fd;font-style:italic>Result</span><span style=color:#ff79c6>&lt;</span>(), <span style=color:#8be9fd;font-style:italic>Box</span><span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>dyn</span> std::error::Error<span style=color:#ff79c6>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    dotenv().ok();
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> alchemy_api_key <span style=color:#ff79c6>=</span> dotenv::var(<span style=color:#f1fa8c>&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style=color:#f1fa8c>&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> web3 <span style=color:#ff79c6>=</span> web3::Web3::new(web3::transports::WebSocket::new(<span style=color:#ff79c6>&amp;</span>alchemy_api_key).<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> contract_address <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85&#34;</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> event_signature <span style=color:#ff79c6>=</span> <span style=color:#f1fa8c>&#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> filter <span style=color:#ff79c6>=</span> web3::types::FilterBuilder::default()
</span></span><span style=display:flex><span>        .address(vec![contract_address.parse().unwrap()])
</span></span><span style=display:flex><span>        .from_block(web3::types::BlockNumber::Latest)
</span></span><span style=display:flex><span>        .topics(
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>Some</span>(vec![event_signature.parse().unwrap()]),
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>None</span>,
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>None</span>,
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>None</span>,
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        .build();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>let</span> transfer_listen <span style=color:#ff79c6>=</span> web3.eth_subscribe().subscribe_logs(filter).<span style=color:#ff79c6>await</span><span style=color:#ff79c6>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    transfer_listen
</span></span><span style=display:flex><span>        .for_each(<span style=color:#ff79c6>|</span>log<span style=color:#ff79c6>|</span> {
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>let</span> id <span style=color:#ff79c6>=</span> format!(<span style=color:#f1fa8c>&#34;{:?}&#34;</span>, log.unwrap().topics[<span style=color:#bd93f9>3</span>]);
</span></span><span style=display:flex><span>            println!(<span style=color:#f1fa8c>&#34;id NOT decoded: {:?}&#34;</span>, id);
</span></span><span style=display:flex><span>            <span style=color:#8be9fd;font-style:italic>let</span> id_decoded <span style=color:#ff79c6>=</span> U256::from_str_radix(<span style=color:#ff79c6>&amp;</span>id[<span style=color:#bd93f9>2</span><span style=color:#ff79c6>..</span>], <span style=color:#bd93f9>16</span>).unwrap();
</span></span><span style=display:flex><span>            println!(<span style=color:#f1fa8c>&#34;id decoded: {:?}&#34;</span>, id_decoded);
</span></span><span style=display:flex><span>            println!(<span style=color:#f1fa8c>&#34;----------&#34;</span>);
</span></span><span style=display:flex><span>            future::ready(())
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .<span style=color:#ff79c6>await</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd;font-style:italic>Ok</span>(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>The result should be this:</strong></p><p><img src=/images/post_pics/simple_rust_oracle/transferid.jpg alt></p><h2 id=5-do-you-need-to-develop-an-oracle-or-a-bridge>5. Do you need to develop an oracle or a bridge?</h2><p>You can contact me <a href=https://www.linkedin.com/in/lorenzo-zaccagnini/>Lorenzo Zaccagnini</a> or <a href=https://www.linkedin.com/in/elisa-romondia/>Elisa Romondia</a> on LinkedIn. If you want to support me you can donate eth or matic to 0xbf8d0d4be61De94EFCCEffbe5D414f911F11cBF8</p></div></article><hr><p class=articleTagsContainer><span></span>
<strong>Tags:</strong>
<a href=/tags/alchemy>#alchemy</a>
<a href=/tags/blockchain>#blockchain</a>
<a href=/tags/infura>#infura</a>
<a href=/tags/oracle>#oracle</a>
<a href=/tags/rust>#rust</a>
<a href=/tags/web3>#web3</a></p><a style=margin-bottom:24px;display:inline-block class=shareBtn onclick=openFediInstanceDialog()>Share on the Fediverse</a><div id=fediInstanceDialog><div class=bg onclick=closeFediInstanceDialog()></div><div class=dialog><h2>Enter your instance's address</h2><input id=fediInstanceInput placeholder='Eg. mastodon.social' type=text><div class=buttons><a class=shareBtn onclick=closeFediInstanceDialog()>Cancel</a>
<a class=shareBtn onclick=shareOnFedi()>Share</a></div></div></div><script>var articleTitle="Develop an Ethereum oracle with Rust",articleLink="https://lorenzozaccagnini.github.io/posts/simple-rust-oracle/",fediInstanceDialog=document.getElementById("fediInstanceDialog"),fediInstanceInput=document.getElementById("fediInstanceInput");function openFediInstanceDialog(){fediInstanceDialog.classList.add("open")}function closeFediInstanceDialog(){fediInstanceDialog.classList.remove("open")}function fixURL(e){return e.substr(0,8)=="https://"?e:e.substr(0,7)=="http://"?e:"https://"+e}function shareOnFedi(){let e=fediInstanceInput.value.trim();if(!e)return;e=fixURL(e),window.open(`${e}/share?text=${articleTitle}%20${articleLink}`,"__blank"),closeFediInstanceDialog()}</script><div class=relatedArticlesContainer><hr><h2>More posts like this</h2><div class=postlist><article class="card postlistitem"><div><h2><a href=https://lorenzozaccagnini.github.io/posts/soulbound-nft/>Develop a Soulbound NFT using Foundry and Slither</a></h2><p class=date><span title=Date></span>
2022-08-16
|
<span title=Tags></span>
<a href=/tags/blockchain>#blockchain</a>
<a href=/tags/cybersecurity>#cybersecurity</a>
<a href=/tags/foundry>#foundry</a>
<a href=/tags/hardhat>#hardhat</a>
<a href=/tags/nft>#nft</a>
<a href=/tags/slither>#slither</a></p><a class=unstyledLink href=https://lorenzozaccagnini.github.io/posts/soulbound-nft/><img src=/images/post_pics/soulbound-nft-cover.jpg></a><div class=articlePreview><p>Today we will develop a Soulbound NFT, an NFT that can be only minted and not traded or transferred, it is bounded to the first owner. We&rsquo;ll do it using foundry with hardhat integrated. The Github workflow will test (foundry solidity and hardhat typescript) the contracts and uses Slither to statically analyze the code, trying to find the most common vulnerabilities.
You can find all the code used in my repository here</p><p><a href=https://lorenzozaccagnini.github.io/posts/soulbound-nft/>Continue reading </a></p></div></div><hr></article></div></div></main><footer><hr><p><small>2022 &copy; Lorenzo Zaccagnini- <a href=https://creativecommons.org/licenses/by/4.0/>Creative Commons Attribution 4.0 International License</a>.</small></p><p><small><a href=https://gitlab.com/gabmus/hugo-ficurinia>Ficurinia theme</a> for <a href=https://gohugo.io>Hugo</a> by <a href=https://gabmus.org>Gabriele Musco</a>. Licensed under <a href=https://www.gnu.org/licenses/agpl-3.0.html>GNU AGPLv3</a>.</small></p></footer></div></div></div></body></html>