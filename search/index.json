{"pages":[{"date":"2022-10-22","image":"/images/post_pics/oraclecover.jpg","link":"https://lorenzozaccagnini.github.io/posts/simple-rust-oracle/","summary":"A blockhain oracle is a service that allows smart contracts to interact with external data sources. In this post, we will develop a simple oracle that will track everytime a Ethereum Name Service NFT is transferred. We will use Rust and the web3 crate to interact with the Ethereum blockchain.\n1. Why blockchains can\u0026rsquo;t access external data sources Blockchains can\u0026rsquo;t access external data sources natively because it is a deterministic system.","tags":["alchemy","blockchain","infura","oracle","rust","web3"],"text":"a blockhain oracle is a service that allows smart contracts to interact with external data sources. in this post, we will develop a simple oracle that will track everytime a ethereum name service nft is transferred. we will use rust and the web3 crate to interact with the ethereum blockchain.\n1. why blockchains can\u0026rsquo;t access external data sources blockchains can\u0026rsquo;t access external data sources natively because it is a deterministic system. each node in the network has a copy of the blockchain, they must all agree on the same state. if a smart contract was able to access external data sources, it would break the deterministic nature of the blockchain. the verification of the state of the blockchain would be impossible, remember same inputs always produce the same outputs.\nwe can solve this problem by using a blockchain oracle. a blockchain oracle is a service that allows smart contracts to interact with external data sources. the oracle will be responsible for fetching the external data and sending it to the smart contract. the smart contract will then be able to access the data.\nlet\u0026rsquo;s make an example to illustrate this. let\u0026rsquo;s say we have a smart contract that stores the current price of a cryptocurrency. if the price of the cryptocurrency is updated every 10 seconds on an external api, the smart contract will have to be updated every 10 seconds, otherwise the smart contract will be out of sync. it would impossible for others to verify the state of the blockchain.\nthis is why blockchains need oracles, external data must be fed into the blockchain with a transaction, in this way all nodes in the network will have the same data and the blockchain will remain deterministic.\nread this fantastic answer on stackoverflow to learn more about that\nin my experience i\u0026rsquo;ve developed many blockchain oracles, for our project devoleum and for many other projects. i\u0026rsquo;ve used different langauges but rust is the one that i love the most. i\u0026rsquo;ve developed oracles for various use cases:\ncrosschain bridges connecting iot to the ethereum blockchain display data from the blockchain for a frontend that does not have access to the blockchain via a browser wallet like metamask. 2. what is an oracle? most of the time is a simple service that listens to events on the blockchain and updates the state of the smart contract. it can also be a smart contract that is called by other smart contracts to get external data. in this article we will develop a simple service that will listen to events on the ethereum blockchain, more precisely the transfer event of ens nfts.\ndifferent types of oracles exist, some of them are:\ninbound oracles: they listen to events on the blockchain outbound oracles: they send transactions to the blockchain hybrid oracles: they listen to events on the blockchain and send transactions to the blockchain 3. setup the ethereum oracle project we will develop a simple oracle that will listen to the transfer event of ens nfts. we will use rust and the web3 crate to interact with the ethereum blockchain. we will use the alchemy api to interact with the ethereum blockchain, otherwise it will be necessary to run a full node.\n3.1. install rust if you don\u0026rsquo;t have rust installed on your machine, you can follow the official installation guide.\n3.2. create a new project we will use the cargo command to create a new project. cargo is the rust package manager and build system.\ncargo new simple-rust-oracle 3.3. add the dependencies we will add the web3 and other dependencies to our cargo.toml file:\nweb3: the web3 crate is a rust library for interacting with ethereum and other blockchain nodes. it provides a full set of features for interacting with the blockchain, including sending transactions, reading data from the blockchain, and listening to events. tokio is a runtime for asynchronous rust applications. the dotenv crate is used to load environment variables from a .env file, we\u0026rsquo;ll use it to load our alchemy api key without hardcoding it in our code (and exposing it to the world). ethnum is used to handle big unsigned integers. this how our cargo.toml file should look like:\n[dependencies] web3 = \u0026#34;0.17.0\u0026#34; tokio = { version= \u0026#34;1\u0026#34;, features = [\u0026#34;full\u0026#34;] } dotenv = \u0026#34;0.15.0\u0026#34; ethnum = \u0026#34;1.3.0\u0026#34; 3.4. create a .env file we will create a .env file in the root of our project. we will store our alchemy api key in this file and load it with the dotenv crate.\nyou can use infura instead of alchemy, just replace the alchemy api key with your infura api key.\nin both cases you have to signup to get an api key. i will use the mainnet api key to listen to the ens nfts transfer events. you can use the testnet api key if you want to test the oracle on the testnet.\ntouch .env the .env file should look like this:\nalchemy_api_key=wss://eth-mainnet.g.alchemy.com/v2/s0mer4nd0mstr1ng 4. develop the ethereum oracle 4.1. load the environment variables we will load the environment variables with the dotenv crate. we will use the dotenv::dotenv() function to load the environment variables from the .env file. we will use the dotenv::var() function to get the value of a specific environment variable.\nuse dotenv::dotenv; fn main() { dotenv().ok(); let alchemy_api_key = dotenv::var(\u0026#34;alchemy_api_key\u0026#34;).expect(\u0026#34;alchemy_api_key must be set\u0026#34;); } 4.2. connect to the ethereum blockchain we will use the web3 crate and the alchemy api to connect to the ethereum blockchain.\nuse dotenv::dotenv; use web3; fn main() { dotenv().ok(); let alchemy_api_key = dotenv::var(\u0026#34;alchemy_api_key\u0026#34;).expect(\u0026#34;alchemy_api_key must be set\u0026#34;); let web3 = web3::web3::new(web3::transports::http::new(\u0026amp;alchemy_api_key).unwrap()); } 4.3. filter to the ens nfts transfer events we need to know the ens smartcontract address to listen to the transfer events. we can find the address of the ens smartcontract on etherscan.\nwait! we want to listen to a specific event, no to every event of the smart contract so we need to know the event signature. the event signature is the hash of the event name and the event parameters.\nsignature or topic0 = 0x + keccak256(\u0026ldquo;transfer(address,address,uint256)\u0026rdquo;))\n0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef = transfer(address,address,uint256)\nas you can see here on etherscan the event signature is 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.\nlet\u0026rsquo;s code it!\nuse dotenv::dotenv; use web3; #[tokio::main] async fn main() -\u0026gt; result\u0026lt;(), box\u0026lt;dyn std::error::error\u0026gt;\u0026gt; { dotenv().ok(); let alchemy_api_key = dotenv::var(\u0026#34;alchemy_api_key\u0026#34;).expect(\u0026#34;alchemy_api_key must be set\u0026#34;); let web3 = web3::web3::new(web3::transports::websocket::new(\u0026amp;alchemy_api_key).await?); let contract_address = \u0026#34;0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85\u0026#34;; let event_signature = \u0026#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\u0026#34;; let filter = web3::types::filterbuilder::default() .address(vec![contract_address.parse().unwrap()]) .from_block(web3::types::blocknumber::latest) .topics( some(vec![event_signature.parse().unwrap()]), none, none, none, ) .build(); ok(()) } as you can read i set the contract address and the event signature. i also wrote the filter to listen to the latest block. the filter contains the contract address and the event signature. note that i\u0026rsquo;ve used the topics function to filter to the specific event and tokio to run the code asynchronously.\n4.4. listen and print the ethereum ens transfer events now we need to subscribe to the filter and listen to the events. we will use the web3.eth_subscribe() function to subscribe to the filter. we will use the web3::types::log struct to decode the event data.\nuse dotenv::dotenv; use web3; use web3::futures::{future, streamext}; #[tokio::main] async fn main() -\u0026gt; result\u0026lt;(), box\u0026lt;dyn std::error::error\u0026gt;\u0026gt; { dotenv().ok(); let alchemy_api_key = dotenv::var(\u0026#34;alchemy_api_key\u0026#34;).expect(\u0026#34;alchemy_api_key must be set\u0026#34;); let web3 = web3::web3::new(web3::transports::websocket::new(\u0026amp;alchemy_api_key).await?); let contract_address = \u0026#34;0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85\u0026#34;; let event_signature = \u0026#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\u0026#34;; let filter = web3::types::filterbuilder::default() .address(vec![contract_address.parse().unwrap()]) .from_block(web3::types::blocknumber::latest) .topics( some(vec![event_signature.parse().unwrap()]), none, none, none, ) .build(); let transfer_listen = web3.eth_subscribe().subscribe_logs(filter).await?; transfer_listen .for_each(|log| { println!(\u0026#34;log: {:?}\u0026#34;, log); future::ready(()) }) .await; ok(()) } i\u0026rsquo;ve used future::ready to run the code asynchronously. i\u0026rsquo;ve also used the for_each function to iterate over the events.\nthe result should be this:\n4.5. decode the event data we need to decode the event data to get the transfer details. first we import ethnum, after we decode the event data in the transfer_listen loop. we get the hex string of token id from the fourth topic, after i use from_str_radix() from ethnum to convert the hex string to a u256.\nuse dotenv::dotenv; use ethnum::u256; use web3; use web3::futures::{future, streamext}; #[tokio::main] async fn main() -\u0026gt; result\u0026lt;(), box\u0026lt;dyn std::error::error\u0026gt;\u0026gt; { dotenv().ok(); let alchemy_api_key = dotenv::var(\u0026#34;alchemy_api_key\u0026#34;).expect(\u0026#34;alchemy_api_key must be set\u0026#34;); let web3 = web3::web3::new(web3::transports::websocket::new(\u0026amp;alchemy_api_key).await?); let contract_address = \u0026#34;0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85\u0026#34;; let event_signature = \u0026#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef\u0026#34;; let filter = web3::types::filterbuilder::default() .address(vec![contract_address.parse().unwrap()]) .from_block(web3::types::blocknumber::latest) .topics( some(vec![event_signature.parse().unwrap()]), none, none, none, ) .build(); let transfer_listen = web3.eth_subscribe().subscribe_logs(filter).await?; transfer_listen .for_each(|log| { let id = format!(\u0026#34;{:?}\u0026#34;, log.unwrap().topics[3]); println!(\u0026#34;id not decoded: {:?}\u0026#34;, id); let id_decoded = u256::from_str_radix(\u0026amp;id[2..], 16).unwrap(); println!(\u0026#34;id decoded: {:?}\u0026#34;, id_decoded); println!(\u0026#34;----------\u0026#34;); future::ready(()) }) .await; ok(()) } the result should be this:\n5. do you need to develop an oracle or a bridge? you can contact me lorenzo zaccagnini or elisa romondia on linkedin. if you want to support me you can donate eth or matic to 0xbf8d0d4be61de94efcceffbe5d414f911f11cbf8\n","title":"Develop an Ethereum oracle with Rust"},{"date":"2022-08-16","image":"","link":"https://lorenzozaccagnini.github.io/pages/about/","summary":"Who is Lorenzo \u0026lsquo;Thorrwulf\u0026rsquo; Zaccagnini Smart contract auditor and cryptography nerd, follow me on my Twitch channel Thorrwulf. It\u0026rsquo;s possible to contact me on Telegram at @Thorrwulf.\nI built my first p2p client and hub at 14y in C++, now I prefer Rust. The long part…\nI\u0026rsquo;ve years of experience in teaching and developing web apps (front and backend in Javascript), and decentralized apps on EVM blockchains like Ethereum. I have extensive knowledge about vulnerabilities of smart contracts and web apps, my analysis and audits often appear in national and international media, with topics ranging from contact tracing apps to DAOs NFTs Oracles, and Defi projects.","tags":[],"text":"who is lorenzo \u0026lsquo;thorrwulf\u0026rsquo; zaccagnini smart contract auditor and cryptography nerd, follow me on my twitch channel thorrwulf. it\u0026rsquo;s possible to contact me on telegram at @thorrwulf.\ni built my first p2p client and hub at 14y in c++, now i prefer rust. the long part…\ni\u0026rsquo;ve years of experience in teaching and developing web apps (front and backend in javascript), and decentralized apps on evm blockchains like ethereum. i have extensive knowledge about vulnerabilities of smart contracts and web apps, my analysis and audits often appear in national and international media, with topics ranging from contact tracing apps to daos nfts oracles, and defi projects. i\u0026rsquo;m the co-founder of devoleum, a web app that uses blockchains and linked open data to make supply chain data open and traceable, our project is internationally awarded by forbes usa and many others. in 2016 i have won a national hackathon with an app about geo tracing using e2e cryptography design. i have a psychology msc. i\u0026rsquo;m a privacy and diversity activist.\nhonours, awards, publications october 2021 - hp anche hitler col green pass dopo un attacco hacker. ma già non funziona più (l. bianchi)\nhttps://www.huffingtonpost.it/entry/green-pass-attacco-hacker-sottrae-le-chiavi-per-generarlo-ma-lallarme-dura-poco_it_61792986e4b079111a5eb6a5\napril 2021 - exchange, hacker e annunci di nuove tasse: dilaga il panico nel mondo delle criptovalute (n. borzi)\nhttps://www.ilfattoquotidiano.it/in-edicola/articoli/2021/04/26/exchange-attacchi-hacker-e-annunci-di-nuove-tasse-un-tremito-scuote-il-mondo-delle-criptovalute\nmay 2021 - blockchain technology and sustainable business models:\na case study of devoleum - published paper https://doi.org/10.3390/su13105619\napril 2020 - fq article about italian contact tracing app issues (n. borzi)\nitalian contact tracing app privacy and cybersecurity issues https://www.ilfattoquotidiano.it/in-edicola/articoli/2020/04/23/ombre-e-problemi-della-app-con-cui-vogliono-tracciarci/5779330/\napril 2020 - healthcare data economy (n. borzi)\narticle about the privacy issues in the healthcare data trading sector https://valori.it/emergenza-sanitaria-apre-data-economy/\nnovember 2019 - strategy innovation forum\nselected as a speaker for the blockchain and ai supply chain sector, at the university of venice ca\u0026rsquo; foscari https://www.unive.it/pag/34335/\napril 2019 - italian chamber of deputies\ninvited as a speaker about \u0026ldquo;managing big streams of data using blockchain and ai\u0026rdquo; https://www.youtube.com/watch?v=xoobvszjpxe\nseptember 2018 - 60 women-led startups that are shaking up tech across the globe\ndevoleum is mentioned in the forbes top 60 startups worldwide https://www.forbes.com/sites/allysonkapin/2018/09/19/60-women-led-startups-who-are-shaking-up- tech-across-the-globe/#1bf7fa4075da\nfebruary 2018 - scholarship winner | google developer challenge, mobile web specialist nanodegree by google e udacity\nhttps://www.udacity.com/course/mobile-web-specialist-nanodegree--nd024 selected by google and udacity for my coding skills among more than 200,000 candidate developers.\ndecember 2017 - press about devoleum, il messaggero newspaper, excellence of the universities of rome\nhttp://www.ilmessaggero.it/roma/cronaca/roma_laureati_con_il_pollice_verde_start_up_e_rob ot_per_i_campi_con_l_universita_il_lavoro_e_bio-3454639.html \u0026ldquo;con la startup dei due giovani (riconosciuta anche a parigi), invece, anche i piccoli produttori potranno certificare in maniera chiara ed onesta i loro prodotti\u0026rdquo; camilla mozzetti\ndecember 2017 - press | rtl interview about devoleum\nhttps://www.youtube.com/watch?v=77fmsopnmm4 interview with fulvio giuliani.\nnovember 2017 - press l\u0026rsquo;usine nouvelle about devoleum\nhttps://www.usinenouvelle.com/article/les-reseaux-se-mobilisent-pour-promouvoir-les- femmes-dans-le-numerique-pour-quel-resultat.n619018 \u0026ldquo;des expertes en technologie, telle la développeuse élisa romondia, qui a cofondé devoleum, une marketplace italienne utilisant la blockchain pour certifier et commercialiser des huiles d’olive produites localement.\u0026rdquo; marion garreau\noctober 2017 - press business insider about devoleum\nhttp://www.businessinsider.fr/startups-finalistes-starther-awards-2017?lipi=urn%253ali %253apage%253ad_flagship3_profile_view_base_treasury %253bm4k7ost8qocnu7d5y4sfxq%253d%253d \u0026ldquo;devoleum (italie), cofondé par elisa romondia — marketplace utilisant la blockchain afin de certifier et de commercialiser des huiles d’olives produites localement\u0026rdquo; marie-catherine beuth\noctober 2017 - press forbes about devoleum\nhttps://www.forbes.fr/femmes-at-forbes/starther-awards-la-start-up-medtech-novagray-remporte-le-concours/?lipi=urn%253ali%253apage%253ad_flagship3_profile_view_base_treasury %253briep4cantgwz0zzmycagdw%253d%253d \u0026ldquo;utiliser la blockchain pour certifier et commercialiser les huiles d’olives produites localement.\u0026rdquo; audrey chabal\noctober 2017 - press le figaro about devoleum\nhttp://www.lefigaro.fr/secteur/high-tech/start-up/2017/10/20/32004-20171020artfig00341-qui-est-derriere-novagray-la-start-up-recompensee-par-le-prix-starther.php?lipi=urn%253ali%253apage%253ad_flagship3_profile_view_base_treasury%253bfzib4h%252f1q9aw6lrtca7p7q%253d %253d \u0026ldquo;cette technologie très sophistiquée est également au cœur du projet d\u0026rsquo;elisa romondia, développe use de devoleum, afin de certifier l\u0026rsquo;origine des huiles d\u0026rsquo;olive de son italie natale\u0026rdquo; elisa braun\noctober 2017 - devoleum presented at the station f\nhttps://www.youtube.com/watch?v=xcjevegdjl0 devoleum has been selected from hundreds of european projects to take part in the 2017 starther awards, held at station f in paris, the world\u0026rsquo;s largest campus startup, home to google and facebook. the event was attended by an international jury, the french tech scene and the french government ministers.\noctober 2017 - devoleum presented station f of paris, selected for the starther awards 2017\nhttps://www.facebook.com/meetstarther/videos/vb.303376065588/10155599438350589/? type=2\u0026amp;theater devoleum was in the 10 selected among hundreds of european projects, to be presented at the station f of paris for the starther awards 2017\njuly 2017 - press wired about women in tech\nhttps://www.wired.it/attualita/tech/2017/07/05/silicon-valley-donne-italia/ \u0026ldquo;non solo silicon valley, le donne del tech sono discriminate anche in italia. startuppare e imprenditrici italiane e londinesi raccontano le loro esperienze discriminatorie simili a quelle sotto accusa in usa.\u0026rdquo; alessia camera\njune 2016 - press startup italia about dammi la mano\nhttp://startupitalia.eu/59457-20160627-digithon-startup-hackaton \u0026ldquo;il premio tim, che darà l’accesso al programma di accelerazione tim #wcap per 12 settimane, prevede lezioni e moduli di lab e di mentorship, più un confronto one to one tra professionista e startup \u0026quot; stefania leo\njune 2016 - press gazzetta del mezzogiorno italian newspaper about dammi la mano\nhttp://www.dammilamano.it/assets/images/articolo-giornale-600x455-81.png \u0026ldquo;progetti innovativi innovativi al servizio del nostro futuro\u0026rdquo;\njune 2016 - press il sole 24 ore italian newspaper about dammi la mano\nhttp://www.ilsole24ore.com/art/impresa-e-territori/2016-06-26/piattaforme-online-studenti-e- app-non-perdersi-premiati-digithon-153006.shtml?uuid=adtreyj \u0026ldquo;a “dammi la mano” è andato il premio tim che permette la partecipazione al programma di accelerazione tim #wcap con un percorso della durata di 12 settimane che prevede lezioni e moduli di lab e di mentorship e un confronto one to one tra professionista e startup.\u0026rdquo; andrea biondi\njune 2016 - press ansa about dammi la mano\nhttp://www.ansa.it/puglia/notizie/2016/06/26/vincitori-digithonbisogna-avere-tenacia_8cba16f6- bc1d-46fc-bb11-6e3f434230db.html \u0026ldquo;a dammi la mano, il progetto che consente di accompagnare ed essere accompagnati dai propri cari in tempo reale su google maps tramite l\u0026rsquo;uso del proprio smartphone, va il premio tim che dà l\u0026rsquo;accesso al programma di accelerazione tim #wcap\u0026rdquo;\njune 2016 - tim #wcap prize at digithon 2016\nhttps://www.youtube.com/watch?v=sfi4ruridce with our project \u0026ldquo;dammi la mano\u0026rdquo; we won the tim #wcap prize at digithon 2016, we have been chosen from thousands of projects. digithon 2016 was the first hackathon in italy, after our victory we received a lot of media coverage in national tv news, newspapers and online blogs.\nmarch 2013 - winner of an overseas scholarship\nduring my master degree in psychology at sapienza university of rome, i won an overseas scholarship (3 months) for york university in toronto, canada, with my project on early autism diagnosis.\n","title":"About"},{"date":"2022-08-16","image":"/images/post_pics/soulbound-nft-cover.jpg","link":"https://lorenzozaccagnini.github.io/posts/soulbound-nft/","summary":"Today we will develop a Soulbound NFT, an NFT that can be only minted and not traded or transferred, it is bounded to the first owner. We\u0026rsquo;ll do it using foundry with hardhat integrated. The Github workflow will test (foundry solidity and hardhat typescript) the contracts and uses Slither to statically analyze the code, trying to find the most common vulnerabilities.\nYou can find all the code used in my repository here","tags":["blockchain","cybersecurity","foundry","hardhat","nft","slither"],"text":"today we will develop a soulbound nft, an nft that can be only minted and not traded or transferred, it is bounded to the first owner. we\u0026rsquo;ll do it using foundry with hardhat integrated. the github workflow will test (foundry solidity and hardhat typescript) the contracts and uses slither to statically analyze the code, trying to find the most common vulnerabilities.\nyou can find all the code used in my repository here\n1. install foundry and create the project 1.1 install foundry. curl -l https://foundry.paradigm.xyz | sh 1.2 create the a new foundry project forge init soulbound-nft 1.3 install the openzeppelin library forge install openzeppelin/openzeppelin-contracts 2. write the smart contract rename the smart contract in the src folder to nfttoken.sol or the name you want.\n2.1 use a pragma solidity directive to specify the compiler version. pragma solidity ^0.8.13; use a version above 0.6.0 to avoid errors and previous vulns, like overflow and underflow. i prefer the latest stable version.\n2.2 import the openzeppelin libraries. import \u0026#34;@openzeppelin/contracts/token/erc721/erc721.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/access/ownable.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/utils/counters.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/utils/strings.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/access/ownable.sol\u0026#34;; 2.3 inherit from the erc721 and ownable contract. contract nfttoken is erc721, ownable { ... } ownable is a library that allows the contract to be owned by a single address. later we will implement the onlyowner modifier to allow only the owner to call the functions.\n2.4. setup a counter for the token incremental id. using counters for counters.counter; counters.counter private _tokenidcounter; here we are making a new counter and naming it _tokenidcounter, using the safemath library.\n2.5 setup the token name and symbol. constructor() erc721(\u0026#34;soulbound\u0026#34;, \u0026#34;sbnft\u0026#34;) {} if you feel confident you can even make a factory to create the token.\n2.6. write the safemint function. function safemint(address to) public onlyowner { uint256 tokenid = _tokenidcounter.current(); _tokenidcounter.increment(); _safemint(to, tokenid); } this function is similar to the mint function in the erc721 contract, but it is protected by the onlyowner modifier and uses the _safemint function. an internal function to safely mint a new token. reverts if the given token id already exists. if the target address is a contract, it must implement onerc721received, which is called upon a safe transfer, and return the magic value bytes4(keccak256... otherwise, the transfer is reverted. source openzeppelin documentation.\n2.7 let\u0026rsquo;s implement the soulbound features modifier onetransfer(address from) { require( from == 0x0000000000000000000000000000000000000000, \u0026#34;soulbound nft can\u0026#39;t be transferred\u0026#34; ); _; } function _beforetokentransfer( address from, address to, uint256 tokenid ) internal override onetransfer(from) { super._beforetokentransfer(from, to, tokenid); } the onetransfer modifier is used to prevent the transfer of the token to any other address, the 0x0000000000000000000000000000000000000000 address it\u0026rsquo;s an impossible from address. we implement onetransfer to the _beforetokentransfer function. the _beforetokentransfer overrides the _beforetokentransfer function in the erc721 contract, and it is called before the transfer, now we have a soulbound nft.\n2.8 recap the entire contract. // spdx-license-identifier: mit pragma solidity ^0.8.13; import \u0026#34;@openzeppelin/contracts/token/erc721/erc721.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/access/ownable.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/utils/counters.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/utils/strings.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/access/ownable.sol\u0026#34;; contract nfttoken is erc721, ownable { using counters for counters.counter; counters.counter private _tokenidcounter; constructor() erc721(\u0026#34;soulbound\u0026#34;, \u0026#34;sbnft\u0026#34;) {} modifier onetransfer(address from) { require( from == 0x0000000000000000000000000000000000000000, \u0026#34;soulbound nft can\u0026#39;t be transferred\u0026#34; ); _; } function safemint(address to) public onlyowner { uint256 tokenid = _tokenidcounter.current(); _tokenidcounter.increment(); _safemint(to, tokenid); } function _beforetokentransfer( address from, address to, uint256 tokenid ) internal override onetransfer(from) { super._beforetokentransfer(from, to, tokenid); } } 3. write foundry tests in solidity foundry tests are a way to test the contracts in solidity, they are really fast compared to truffle or hardhat. foundry is made in rust, so it\u0026rsquo;s blazing fast. rename the test contract file in the test folder to nfttoken.t.sol, or the name you want that respects the naming convention namecontract.t.sol.\n3.1 setup the test environment. // spdx-license-identifier: unlicensed pragma solidity ^0.8.13; import \u0026#34;forge-std/test.sol\u0026#34;; import \u0026#34;../src/nfttoken.sol\u0026#34;; contract nfttokentest is test { using stdstorage for stdstorage; nfttoken private nft; function setup() public { nft = new nfttoken(); } } i import the test contract, and the nfttoken contract. nfttokentest is the name of the test contract. we are using the stdstorage, a library that makes manipulating storage easy. setup() is a function that is called before each test, and it initializes the contract.\n3.2 test smart contract functions. here i\u0026rsquo;m testing the smart contract functions. the pattern is easy to understand, we test the function correct output and revert if it\u0026rsquo;s not correct with the vm.expectrevert() function. the vm.startprank() and vm.stopprank() functions are used to simulate a user that is not the owner. by using solidity to write tests we can test the smart contract functions the closest possible to a real user or external contract.\n// spdx-license-identifier: unlicensed pragma solidity ^0.8.13; import \u0026#34;forge-std/test.sol\u0026#34;; import \u0026#34;../src/nfttoken.sol\u0026#34;; contract nfttokentest is test { using stdstorage for stdstorage; nfttoken private nft; function setup() public { nft = new nfttoken(); } function testdeployment() public { asserteq(nft.name(), \u0026#34;soulbound\u0026#34;); asserteq(nft.symbol(), \u0026#34;sbnft\u0026#34;); } function testowner() public { asserteq(nft.owner(), address(this)); } function testmintfailbynotowneruser() public { vm.expectrevert(\u0026#34;ownable: caller is not the owner\u0026#34;); vm.startprank(address(2)); nft.safemint(address(2)); vm.stopprank(); } function testmint() public { nft.safemint(address(1)); asserteq(nft.balanceof(address(1)), 1); asserteq(nft.ownerof(0), address(1)); } function testtransferfail() public { nft.safemint(address(2)); vm.expectrevert(\u0026#34;soulbound nft can\u0026#39;t be transferred\u0026#34;); vm.startprank(address(2)); nft.safetransferfrom(address(2), address(3), 0); vm.stopprank(); } function testownertransfer() public { asserteq(nft.owner(), address(this)); nft.transferownership(0x1111111111111111111111111111111111111111); asserteq(nft.owner(), 0x1111111111111111111111111111111111111111); } function testownertransferfail() public { asserteq(nft.owner(), address(this)); vm.expectrevert(\u0026#34;ownable: caller is not the owner\u0026#34;); vm.startprank(address(2)); nft.transferownership(0x1111111111111111111111111111111111111111); vm.stopprank(); } } 3.3 test contract using forge forge test all test cases should pass.\n4. integrating foundry with hardhat hardhat by default expects libraries to be installed in node_modules, the default folder for all nodejs dependencies. foundry expects them to be in lib. of course we can configure foundry but not easily to the directory structure of node_modules. documentation has more information.\n4.1 install hardhat yarn init yarn add hardhat hardhat-preprocessor npx hardhat forge remappings \u0026gt; remappings.txt you will need to re-run forge remappings everytime you modify libraries in foundry. now your remappings.txt should look like this:\nds-test/=lib/solmate/lib/ds-test/src/ forge-std/=lib/forge-std/src/ openzeppelin-contracts/contracts/=lib/openzeppelin-contracts/contracts/ solmate/=lib/solmate/src/ 4.2 configure hardhat edit hardhat.config.ts to look like this:\nimport fs from \u0026#34;fs\u0026#34;; import \u0026#34;@nomicfoundation/hardhat-chai-matchers\u0026#34;; import \u0026#34;@typechain/hardhat\u0026#34;; import \u0026#34;hardhat-preprocessor\u0026#34;; import { hardhatuserconfig, task } from \u0026#34;hardhat/config\u0026#34;; function getremappings() { return fs .readfilesync(\u0026#34;remappings.txt\u0026#34;, \u0026#34;utf8\u0026#34;) .split(\u0026#34;\\n\u0026#34;) .filter(boolean) .map((line) =\u0026gt; line.trim().split(\u0026#34;=\u0026#34;)); } const config: hardhatuserconfig = { solidity: { version: \u0026#34;0.8.13\u0026#34;, settings: { optimizer: { enabled: true, runs: 200, }, }, }, paths: { sources: \u0026#34;./src\u0026#34;, // use ./src rather than ./contracts as hardhat expects cache: \u0026#34;./cache_hardhat\u0026#34;, // use a different cache for hardhat than foundry }, // this fully resolves paths for imports in the ./lib directory for hardhat preprocess: { eachline: (hre) =\u0026gt; ({ transform: (line: string) =\u0026gt; { if (line.match(/^\\s*import /i)) { getremappings().foreach(([find, replace]) =\u0026gt; { if (line.match(find)) { line = line.replace(find, replace); } }); } return line; }, }), }, }; export default config; 5. write hardhat tests in typescript 5.1 create test contract create the contract in the test folder using this name convention nfttoken.test.ts.\n5.2 write test hardhat file here we do the same as the foundry tests, but we use the hardhat expect and the to.be.revertedwith function. if the revertedwith is not recognized install the \u0026quot;@nomicfoundation/hardhat-chai-matchers package. more info here about this.\nimport { signerwithaddress } from \u0026#34;@nomiclabs/hardhat-ethers/signers\u0026#34;; import { expect } from \u0026#34;chai\u0026#34;; import { ethers } from \u0026#34;hardhat\u0026#34;; import { nfttoken } from \u0026#34;../typechain-types\u0026#34;; describe(\u0026#34;nfttoken\u0026#34;, function () { let owner: signerwithaddress; let addr1: signerwithaddress; let addr2: signerwithaddress; let nft: nfttoken; beforeeach(async function () { const nft = await ethers.getcontractfactory(\u0026#34;nfttoken\u0026#34;); nft = await nft.deploy(); await nft.deployed(); [owner, addr1, addr2] = await ethers.getsigners(); }); it(\u0026#34;should return name and symbol\u0026#34;, async function () { expect(await nft.name()).to.equal(\u0026#34;soulbound\u0026#34;); expect(await nft.symbol()).to.equal(\u0026#34;sbnft\u0026#34;); }); it(\u0026#34;should set the first account as the owner\u0026#34;, async () =\u0026gt; { expect(await nft.owner()).to.equal(owner.address); }); it(\u0026#34;should not mint a token as not the owner\u0026#34;, async () =\u0026gt; { await expect(nft.connect(addr1).safemint(addr1.address)).to.be.revertedwith( \u0026#34;ownable: caller is not the owner\u0026#34; ); }); it(\u0026#34;should mint a token as the owner\u0026#34;, async () =\u0026gt; { await nft.safemint(addr1.address); expect(await nft.ownerof(0)).to.equal(addr1.address); expect(await nft.balanceof(addr1.address)).to.equal(1); }); it(\u0026#34;should not be able to transfer soulbound token\u0026#34;, async () =\u0026gt; { await nft.safemint(owner.address); //overloaded transfer function await expect( nft[\u0026#34;safetransferfrom(address,address,uint256)\u0026#34;]( owner.address, addr2.address, 0 ) ).to.be.revertedwith(\u0026#34;soulbound nft can\u0026#39;t be transferred\u0026#34;); }); it(\u0026#34;should not transfer the contract non owner to the new owner\u0026#34;, async () =\u0026gt; { await expect( nft.connect(addr1).transferownership(addr2.address) ).to.be.revertedwith(\u0026#34;ownable: caller is not the owner\u0026#34;); }); it(\u0026#34;should transfer the contract owner to the new owner\u0026#34;, async () =\u0026gt; { await nft.transferownership(addr2.address); expect(await nft.owner()).to.equal(addr2.address); }); }); different addresses are simulated by using the connect function. the beforeeach function is used to set up the contract and the it function is used to test the contract.\n5.3 hardhat vs forge vs truffle i prefer forge, is faster and closer to the real environment. hardhat right now is optional, but i would recommend using it as an alternative. truffle is now obsolete and will be less and less used in the future.\n6. create a github workflow with tests and slither audit 6.1 create a github workflow create a file named .github/workflows/audit.yml and put this content:\nname: audit on: push: branches: [main, develop] pull_request: branches: [main, develop] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: submodules: recursive - name: install foundry uses: foundry-rs/foundry-toolchain@v1 with: version: nightly - name: run forge build run: | forge --version forge build --sizes id: build - name: run forge tests run: | forge test -vvv id: forge-test this will install foundry and run the forge build and tests. 6.2 optional hardat tests if you want to use hardhat add a step that uses yarn to instal the packages and run the command npx hardhat test, this will run the tests with hardhat.\n- name: setup nodejs 14 uses: actions/setup-node@v2 with: node-version: \u0026#34;14\u0026#34; - name: show nodejs version run: npm --version - name: install dependencies run: npm install - name: run hardhat test run: npx hardhat compile; npx hardhat test should look like this: 6.3 add slither audit slither is a solidity static analysis framework written in python 3. it runs a suite of vulnerability detectors, prints visual information about contract details, and provides an api to easily write custom analyses. slither enables developers to find vulnerabilities, enhance their code comprehension, and quickly prototype custom analyses. source\nwe can even add slither manually, but i prefer to use slither-action command. it\u0026rsquo;s a great tool because will push slither\u0026rsquo;s alerts to the security tab of the github project, easing the triaging of findings and improving the continious integration flow.\n- name: slither-action uses: crytic/slither-action@v0.1.1 continue-on-error: true id: slither with: sarif: results.sarif - name: upload sarif file uses: github/codeql-action/upload-sarif@v2 with: sarif_file: ${{ steps.slither.outputs.sarif }} if everything is correct you will this result in the security tab of the github project: 6.4 recap they yaml file is used to create a github workflow that will run the tests and slither audit. should look like this:\nname: hardhat build on: push: branches: [main, develop] pull_request: branches: [main, develop] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: submodules: recursive - name: install foundry uses: foundry-rs/foundry-toolchain@v1 with: version: nightly - name: run forge build run: | forge --version forge build --sizes id: build - name: run forge tests run: | forge test -vvv id: forge-test - name: setup nodejs 14 uses: actions/setup-node@v2 with: node-version: \u0026#34;14\u0026#34; - name: show nodejs version run: npm --version - name: install dependencies run: yarn - name: run hardhat test run: npx hardhat compile; npx hardhat test - name: slither-action uses: crytic/slither-action@v0.1.1 continue-on-error: true id: slither with: sarif: results.sarif - name: upload sarif file uses: github/codeql-action/upload-sarif@v2 with: sarif_file: ${{ steps.slither.outputs.sarif }} ","title":"Develop a Soulbound NFT using Foundry and Slither"}]}