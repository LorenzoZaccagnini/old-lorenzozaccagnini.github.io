<?xml version="1.0" encoding="utf-8" standalone="yes"?><?xml-stylesheet href="/feed_style.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="https://www.rssboard.org/media-rss"><channel><title>Thorrwulf</title><link>https://lorenzozaccagnini.github.io/</link><description>Recent content on Thorrwulf</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>Lorenzo Zaccagnini- [Creative Commons Attribution 4.0 International License](https://creativecommons.org/licenses/by/4.0/).</copyright><lastBuildDate>Tue, 20 Dec 2022 00:03:47 +0200</lastBuildDate><atom:link href="https://lorenzozaccagnini.github.io/index.xml" rel="self" type="application/rss+xml"/><icon>https://lorenzozaccagnini.github.io/logo.svg</icon><item><title>Intercept pending transactions with Rust</title><link>https://lorenzozaccagnini.github.io/posts/evm-intercept-tx-rad/</link><pubDate>Tue, 20 Dec 2022 00:03:47 +0200</pubDate><guid>https://lorenzozaccagnini.github.io/posts/evm-intercept-tx-rad/</guid><description><![CDATA[<p>Transactions on blockchain are not instant. They are pending until they are confirmed by the network. This is a security feature of the blockchain. This is why it is important to wait for the transaction to be confirmed before sending another transaction. In this article we will see how to intercept pending transactions with rust.</p>
<h2 id="1-transaction-lifecycle">1. Transaction lifecycle</h2>
<p>An Ethereum transaction lifecycle is as follows:</p>
<ol>
<li>The transaction is created and signed by the sender.</li>
<li>The transaction is broadcasted to the network.</li>
<li>The transaction is pending until it is confirmed by the network.</li>
<li>The transaction is confirmed by the network.</li>
</ol>
<p>The transaction is confirmed when it is included in a block. On Ethereum proof of stake network, the block is produced by a validator. The validator is a node that is running the Ethereum client and is participating in the consensus. The validator is selected randomly from the network. The validator is selected based on the stake that the validator has in the network.</p>
<h2 id="2-the-mempool">2. The Mempool</h2>
<p>The mempool is a pool of pending transactions. The transactions are pending until they are confirmed by the network. On Ethereum we don&rsquo;t have a single universal mempool. Each node has its own mempool. Even different clients use different jargon for the mempool.</p>
<ul>
<li>On Geth the mempool is called the transaction pool.</li>
<li>On Parity the mempool is called the transaction queue.</li>
</ul>
<h3 id="21-why-intercept-pending-transactions">2.1 Why intercept pending transactions?</h3>
<p>There are many reasons and one of them is money, some bots intercept pending transactions to make a profit. Front running means that a bot will intercept a pending transaction and will execute another transaction before the original sender. It&rsquo;s possibile to frontrun a transaction by increasing the gas price. The gas price is the amount of money that the sender is willing to pay for the transaction to be confirmed. The higher the gas price, the higher the priority of the transaction.</p>
<p>Let&rsquo;s make an example, you are trading a token on Uniswap and you want to buy 100 tokens. You set the gas price to 10 Gwei and the transaction is pending. A bot sees your transaction in the pool and increases the gas price to 20 Gwei. Your transaction is now pending and the bot&rsquo;s transaction is confirmed before yours. The bot knows that your transaction will be executed and he will sell the tokens to you at a higher price. <strong>This is called frontrunning</strong>.</p>
<h3 id="22-do-you-want-a-sandwich">2.2 Do you want a sandwich?</h3>
<p>The Ethereum network is a public network and anyone can see the pending transactions. It is possible to intercept pending transactions and make a profit. The bot will increase the gas price of the transaction and will execute the transaction before the original sender. <strong>The sandwich trading strategy is a type of front and back running</strong>, <a href="https://github.com/Defi-Cartel/salmonella">it&rsquo;s about placing a trade before and after a target trade, in order to make a profit on the slippage that has been created</a>. The bot will buy the token and sell it to the original sender at a higher price. The bot will make a profit by selling the token at a higher price.</p>
<p>In a future article we will see how to make a sandwich, but for now let&rsquo;s see how to intercept and decode pending transactions.</p>
<h3 id="23-generalized-frontrunners">2.3 Generalized frontrunners</h3>
<p>Rather than programming complex algorithms to detect profitable MEV opportunities, some searchers run generalized frontrunners. Generalized frontrunners are bots that watch the mempool to detect profitable transactions. The frontrunner will copy the potentially profitable transaction&rsquo;s code, replace addresses with the frontrunner&rsquo;s address, and run the transaction locally to double-check that the modified transaction results in a profit to the frontrunner&rsquo;s address. If the transaction is indeed profitable, the frontrunner will submit the modified transaction with the replaced address and a higher gas price, &ldquo;frontrunning&rdquo; the original transaction and getting the original searcher&rsquo;s MEV. <a href="https://ethereum.org/en/developers/docs/mev/#mev-extraction-generalized-frontrunners">Ethereum.org Source</a></p>
<h2 id="3-intercept-pending-transactions-with-rust">3. Intercept pending transactions with rust</h2>
<p>In this section we will see how to intercept pending transactions with rust. We will use the web3 library to interact with the Ethereum network. We will use the web3 library to intercept pending transactions and we will use the dotenv library to load the environment variables of alchemy.</p>
<p>All the code is available on my <a href="https://github.com/LorenzoZaccagnini/EVM-intecept-tx-bot-rust">github</a></p>
<h3 id="31-create-a-new-rust-project">3.1 Create a new rust project</h3>
<p>Create a new rust project with cargo:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cargo new intercept_tx
</span></span></code></pre></div><p>Add the dependencies to the Cargo.toml file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[package]
</span></span><span style="display:flex;"><span>name = <span style="color:#f1fa8c">&#34;evm-intercept-tx&#34;</span>
</span></span><span style="display:flex;"><span>version = <span style="color:#f1fa8c">&#34;0.1.0&#34;</span>
</span></span><span style="display:flex;"><span>edition = <span style="color:#f1fa8c">&#34;2021&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[dependencies]
</span></span><span style="display:flex;"><span>dotenv = <span style="color:#f1fa8c">&#34;0.15.0&#34;</span>
</span></span><span style="display:flex;"><span>hex = <span style="color:#f1fa8c">&#34;0.4.3&#34;</span>
</span></span><span style="display:flex;"><span>tokio = <span style="color:#f1fa8c">&#34;1.21.2&#34;</span>
</span></span><span style="display:flex;"><span>web3 = <span style="color:#f1fa8c">&#34;0.18.0&#34;</span>
</span></span></code></pre></div><h3 id="32-load-the-environment-variables">3.2 Load the environment variables</h3>
<p>Create a .env file and add the alchemy api key:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">ALCHEMY_API_KEY</span><span style="color:#ff79c6">=</span>your_alchemy_api_key
</span></span></code></pre></div><p>Add the dotenv library to the main.rs file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">use</span> dotenv::dotenv;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> hex;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::futures::TryStreamExt;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::types::TransactionId;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() -&gt; <span style="color:#50fa7b">web3</span>::<span style="color:#8be9fd;font-style:italic">Result</span> {
</span></span><span style="display:flex;"><span>    dotenv().ok();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> alchemy_api_key <span style="color:#ff79c6">=</span> dotenv::var(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="33-connect-to-the-ethereum-network">3.3 Connect to the Ethereum network</h3>
<p>Add the web3 library to the main.rs file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() -&gt; <span style="color:#50fa7b">web3</span>::<span style="color:#8be9fd;font-style:italic">Result</span> {
</span></span><span style="display:flex;"><span>    dotenv().ok();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> alchemy_api_key <span style="color:#ff79c6">=</span> dotenv::var(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3 <span style="color:#ff79c6">=</span> web3::Web3::new(web3::transports::WebSocket::new(<span style="color:#ff79c6">&amp;</span>alchemy_api_key).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now you should be able to connect to the Ethereum network.</p>
<h3 id="34-intercept-pending-transactions">3.4 Intercept pending transactions</h3>
<p>Here we will use the &lsquo;subscribe_new_pending_transactions&rsquo; method of web3 to intercept pending transactions. The &lsquo;subscribe_new_pending_transactions&rsquo; method returns a stream of pending transactions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">use</span> dotenv::dotenv;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> hex;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::futures::TryStreamExt;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::types::TransactionId;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() -&gt; <span style="color:#50fa7b">web3</span>::<span style="color:#8be9fd;font-style:italic">Result</span> {
</span></span><span style="display:flex;"><span>    dotenv().ok();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> alchemy_api_key <span style="color:#ff79c6">=</span> dotenv::var(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3 <span style="color:#ff79c6">=</span> web3::Web3::new(web3::transports::WebSocket::new(<span style="color:#ff79c6">&amp;</span>alchemy_api_key).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> pending_transactions <span style="color:#ff79c6">=</span> web3
</span></span><span style="display:flex;"><span>        .eth_subscribe()
</span></span><span style="display:flex;"><span>        .subscribe_new_pending_transactions()
</span></span><span style="display:flex;"><span>        .<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">while</span> <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#8be9fd;font-style:italic">Some</span>(pending_transaction_hash) <span style="color:#ff79c6">=</span> pending_transactions.try_next().<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> transaction <span style="color:#ff79c6">=</span> web3
</span></span><span style="display:flex;"><span>            .eth()
</span></span><span style="display:flex;"><span>            .transaction(TransactionId::from(pending_transaction_hash))
</span></span><span style="display:flex;"><span>            .<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#8be9fd;font-style:italic">Some</span>(transaction) <span style="color:#ff79c6">=</span> transaction {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#f1fa8c">&#34;Transaction hash: {}&#34;</span>, transaction);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">Ok</span>(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now we are logging every pending transaction in the node mempool. The &lsquo;subscribe_new_pending_transactions&rsquo; method returns a stream of pending transactions. The stream is an iterator that returns a pending transaction hash. We can use the &rsquo;transaction&rsquo; method of web3 to get the transaction details. The &rsquo;transaction&rsquo; method returns a transaction object. The transaction object contains the transaction details.</p>
<h3 id="35-filter-pending-transactions">3.5 Filter pending transactions</h3>
<p>We can filter pending transactions by the destination address. We can use the &rsquo;to&rsquo; field of the transaction object to filter the transactions. The &rsquo;to&rsquo; field contains the destination address of the transaction.</p>
<p>The address 0x31c8eacbffdd875c74b94b077895bd78cf1e64a3 is the RAD token. We will intercept the pending transactions of the RAD token.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">use</span> dotenv::dotenv;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> hex;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::futures::TryStreamExt;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::types::TransactionId;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() -&gt; <span style="color:#50fa7b">web3</span>::<span style="color:#8be9fd;font-style:italic">Result</span> {
</span></span><span style="display:flex;"><span>    dotenv().ok();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> alchemy_api_key <span style="color:#ff79c6">=</span> dotenv::var(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3 <span style="color:#ff79c6">=</span> web3::Web3::new(web3::transports::WebSocket::new(<span style="color:#ff79c6">&amp;</span>alchemy_api_key).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> pending_transactions <span style="color:#ff79c6">=</span> web3
</span></span><span style="display:flex;"><span>        .eth_subscribe()
</span></span><span style="display:flex;"><span>        .subscribe_new_pending_transactions()
</span></span><span style="display:flex;"><span>        .<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//filter transaction based on address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">let</span> address <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0x31c8eacbffdd875c74b94b077895bd78cf1e64a3&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">while</span> <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#8be9fd;font-style:italic">Some</span>(pending_transaction_hash) <span style="color:#ff79c6">=</span> pending_transactions.try_next().<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> transaction <span style="color:#ff79c6">=</span> web3
</span></span><span style="display:flex;"><span>            .eth()
</span></span><span style="display:flex;"><span>            .transaction(TransactionId::from(pending_transaction_hash))
</span></span><span style="display:flex;"><span>            .<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#8be9fd;font-style:italic">Some</span>(transaction) <span style="color:#ff79c6">=</span> transaction {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">//filter transaction based on address and method hash
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">if</span> transaction.to <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">Some</span>(address.parse().unwrap()) {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//decode input data bytes to hex
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                println!(<span style="color:#f1fa8c">&#34;transaction: {:?}&#34;</span>, transaction);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">Ok</span>(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>You should be able to intercept the pending transactions of the RAD token and see a log like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>transaction: Transaction <span style="color:#ff79c6">{</span> hash: 0x4d5564bbedd6eb902e91b3c6a1d10a4c4029a036e9c4610fd6375932e2636e95, nonce: 5442921, block_hash: Some<span style="color:#ff79c6">(</span>0x15ba42779e7d34714607312e6b4f33f9a926738e527593402ff4ad15c1c7c7c2<span style="color:#ff79c6">)</span>, block_number: Some<span style="color:#ff79c6">(</span>16228505<span style="color:#ff79c6">)</span>, transaction_index: Some<span style="color:#ff79c6">(</span>28<span style="color:#ff79c6">)</span>, from: Some<span style="color:#ff79c6">(</span>0x28c6c06298d514db089934071355e5743bf21d60<span style="color:#ff79c6">)</span>, to: Some<span style="color:#ff79c6">(</span>0x31c8eacbffdd875c74b94b077895bd78cf1e64a3<span style="color:#ff79c6">)</span>, value: 0, gas_price: Some<span style="color:#ff79c6">(</span>16185590269<span style="color:#ff79c6">)</span>, gas: 207128, input: Bytes<span style="color:#ff79c6">([</span>169, 5, 156, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 160, 138, 28, 191, 39, 255, 75, 202, 197, 95, 205, 201, 124, 116, 141, 91, 81, 39, 96, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 136, 108, 144, 48, 150, 116, 138, 0, 0<span style="color:#ff79c6">])</span>, v: Some<span style="color:#ff79c6">(</span>0<span style="color:#ff79c6">)</span>, r: Some<span style="color:#ff79c6">(</span>55005093721274821805649449657760135373297623073244198928033742057513000728837<span style="color:#ff79c6">)</span>, s: Some<span style="color:#ff79c6">(</span>19584657317945855950856553141997014012848398946606485974435162940290921668925<span style="color:#ff79c6">)</span>, raw: None, transaction_type: Some<span style="color:#ff79c6">(</span>2<span style="color:#ff79c6">)</span>, access_list: Some<span style="color:#ff79c6">([])</span>, max_fee_per_gas: Some<span style="color:#ff79c6">(</span>102000000000<span style="color:#ff79c6">)</span>, max_priority_fee_per_gas: Some<span style="color:#ff79c6">(</span>2000000000<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">}</span>
</span></span></code></pre></div><h3 id="36-decode-input-data">3.6 Decode input data</h3>
<p>Now we can intercept a pending transaction, but how to decode the input data? The input data is a byte array. We can use the &rsquo;ethabi&rsquo; crate to decode the input data, but in this simple case I will use the &lsquo;hex&rsquo; crate to decode the input data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">use</span> dotenv::dotenv;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> hex;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::futures::TryStreamExt;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::types::TransactionId;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() -&gt; <span style="color:#50fa7b">web3</span>::<span style="color:#8be9fd;font-style:italic">Result</span> {
</span></span><span style="display:flex;"><span>    dotenv().ok();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> alchemy_api_key <span style="color:#ff79c6">=</span> dotenv::var(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3 <span style="color:#ff79c6">=</span> web3::Web3::new(web3::transports::WebSocket::new(<span style="color:#ff79c6">&amp;</span>alchemy_api_key).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#ff79c6">mut</span> pending_transactions <span style="color:#ff79c6">=</span> web3
</span></span><span style="display:flex;"><span>        .eth_subscribe()
</span></span><span style="display:flex;"><span>        .subscribe_new_pending_transactions()
</span></span><span style="display:flex;"><span>        .<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//filter transaction based on address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">let</span> address <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0x31c8eacbffdd875c74b94b077895bd78cf1e64a3&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">while</span> <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#8be9fd;font-style:italic">Some</span>(pending_transaction_hash) <span style="color:#ff79c6">=</span> pending_transactions.try_next().<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> transaction <span style="color:#ff79c6">=</span> web3
</span></span><span style="display:flex;"><span>            .eth()
</span></span><span style="display:flex;"><span>            .transaction(TransactionId::from(pending_transaction_hash))
</span></span><span style="display:flex;"><span>            .<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> <span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#8be9fd;font-style:italic">Some</span>(transaction) <span style="color:#ff79c6">=</span> transaction {
</span></span><span style="display:flex;"><span>            <span style="color:#6272a4">//filter transaction based on address and method hash
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>            <span style="color:#ff79c6">if</span> transaction.to <span style="color:#ff79c6">==</span> <span style="color:#8be9fd;font-style:italic">Some</span>(address.parse().unwrap()) {
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//decode input data bytes to hex
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                <span style="color:#8be9fd;font-style:italic">let</span> tx_clone <span style="color:#ff79c6">=</span> transaction.clone();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> input_data <span style="color:#ff79c6">=</span> transaction.input.<span style="color:#bd93f9">0</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> input_data_hex <span style="color:#ff79c6">=</span> hex::encode(input_data);
</span></span><span style="display:flex;"><span>                println!(<span style="color:#f1fa8c">&#34;tx input hex: {:?}&#34;</span>, input_data_hex);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//decode using abi
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">if</span> input_data_hex.starts_with(<span style="color:#f1fa8c">&#34;a9059cbb&#34;</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#8be9fd;font-style:italic">let</span> raw_amount <span style="color:#ff79c6">=</span> input_data_hex[<span style="color:#bd93f9">74</span><span style="color:#ff79c6">..</span>].to_string();
</span></span><span style="display:flex;"><span>                    println!(<span style="color:#f1fa8c">&#34;Raw Amount cutted hex: {:?}&#34;</span>, raw_amount);
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">//decode raw amount to u256
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#8be9fd;font-style:italic">let</span> raw_amount <span style="color:#ff79c6">=</span> hex::decode(raw_amount).unwrap();
</span></span><span style="display:flex;"><span>                    <span style="color:#6272a4">//convert to u256
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                    <span style="color:#8be9fd;font-style:italic">let</span> raw_amount <span style="color:#ff79c6">=</span> web3::types::U256::from_big_endian(<span style="color:#ff79c6">&amp;</span>raw_amount);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                    println!(<span style="color:#f1fa8c">&#34;//---------------------------------------//&#34;</span>);
</span></span><span style="display:flex;"><span>                    println!(<span style="color:#f1fa8c">&#34;Raw Amount: {:?}&#34;</span>, raw_amount);
</span></span><span style="display:flex;"><span>                    println!(<span style="color:#f1fa8c">&#34;Transaction: {:?}&#34;</span>, tx_clone);
</span></span><span style="display:flex;"><span>                    println!(<span style="color:#f1fa8c">&#34;//---------------------------------------//&#34;</span>);
</span></span><span style="display:flex;"><span>                    println!(<span style="color:#f1fa8c">&#34;Transfer in pending towards RAD token contract&#34;</span>);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">Ok</span>(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Let&rsquo;s break it down, &rsquo;let input_data = transaction.input.0;&rsquo; is the input data of the transaction, a byte array. We can convert it to a hex string with &rsquo;let input_data_hex = hex::encode(input_data);&rsquo;.</p>
<p>Now we can filter the input data based on the method hash. In this case we are looking for the &rsquo;transfer&rsquo; method hash &lsquo;a9059cbb&rsquo;. If the input data starts with &lsquo;a9059cbb&rsquo; we can cut the first 74 characters of the input data hex string. The first 74 characters are the method hash and the address of the receiver.</p>
<p>The rest of the input data is the amount. We can convert the rest of the input data to a u256 with &rsquo;let raw_amount = web3::types::U256::from_big_endian(&amp;raw_amount);&rsquo;. Now we have the amount of the transfer in pending. We can also print the transaction to see the other data of the transaction. You should see a log like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tx input hex: <span style="color:#f1fa8c">&#34;a9059cbb000000000000000000000000b51da94ae51c339cec40d78260199f73cebbeba8000000000000000000000000000000000000000000000015954d6c905a060000&#34;</span>
</span></span><span style="display:flex;"><span>Raw Amount cutted hex: <span style="color:#f1fa8c">&#34;0000000000000000000000000000000000000000000015954d6c905a060000&#34;</span>
</span></span><span style="display:flex;"><span>//---------------------------------------//
</span></span><span style="display:flex;"><span>Raw Amount: <span style="color:#bd93f9">398140000000000000000</span>
</span></span><span style="display:flex;"><span>Transaction: Transaction <span style="color:#ff79c6">{</span> hash: 0xee7013a832ff032fd43fc296e6ea6ffead097db2122981eb971f7f4fd5c5d0dc, nonce: 4931764, block_hash: Some<span style="color:#ff79c6">(</span>0x7fc256c3640e02070d726a8f504948609d5100cbc50910515cffa708a4b01b1c<span style="color:#ff79c6">)</span>, block_number: Some<span style="color:#ff79c6">(</span>16228188<span style="color:#ff79c6">)</span>, transaction_index: Some<span style="color:#ff79c6">(</span>35<span style="color:#ff79c6">)</span>, from: Some<span style="color:#ff79c6">(</span>0xdfd5293d8e347dfe59e90efd55b2956a1343963d<span style="color:#ff79c6">)</span>, to: Some<span style="color:#ff79c6">(</span>0x31c8eacbffdd875c74b94b077895bd78cf1e64a3<span style="color:#ff79c6">)</span>, value: 0, gas_price: Some<span style="color:#ff79c6">(</span>20264315737<span style="color:#ff79c6">)</span>, gas: 207128, input: Bytes<span style="color:#ff79c6">([</span>169, 5, 156, 187, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 181, 29, 169, 74, 229, 28, 51, 156, 236, 64, 215, 130, 96, 25, 159, 115, 206, 187, 235, 168, 0, 0, 0, 0, 0, 0,
</span></span><span style="display:flex;"><span>0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 149, 77, 108, 144, 90, 6, 0, 0<span style="color:#ff79c6">])</span>, v: Some<span style="color:#ff79c6">(</span>1<span style="color:#ff79c6">)</span>, r: Some<span style="color:#ff79c6">(</span>94476206653139298663972815699772140255840765385329375194390453406687512516529<span style="color:#ff79c6">)</span>, s: Some<span style="color:#ff79c6">(</span>34590948637004618330444175192055263866731258644152094038657143970283606957875<span style="color:#ff79c6">)</span>, raw: None, transaction_type: Some<span style="color:#ff79c6">(</span>2<span style="color:#ff79c6">)</span>, access_list: Some<span style="color:#ff79c6">([])</span>, max_fee_per_gas: Some<span style="color:#ff79c6">(</span>102000000000<span style="color:#ff79c6">)</span>, max_priority_fee_per_gas: Some<span style="color:#ff79c6">(</span>2000000000<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">}</span>
</span></span><span style="display:flex;"><span>//---------------------------------------//
</span></span><span style="display:flex;"><span>Transfer in pending towards RAD token contract
</span></span></code></pre></div><p>You can confront the values here with the values <a href="https://etherscan.io/tx/0xee7013a832ff032fd43fc296e6ea6ffead097db2122981eb971f7f4fd5c5d0dc">on the Etherscan transaction page</a>.</p>
<h2 id="5-conclusion">5. Conclusion</h2>
<p>You can see that we know the gas details and the token amount of the transaction, guess what you can do with that information. You can use it to calculate the gas price and the gas cost of the transaction. You can also use it to calculate the amount of tokens that will be transferred when the transaction is confirmed and front-run the transaction.</p>
<p>Maybe in a future article we will see how to front-run a transaction. If you have any questions or suggestions, please let me know.</p>
<h2 id="7-do-you-need-to-develop-a-mev-bot">7. Do you need to develop a MEV bot?</h2>
<p>You can contact me <a href="https://www.linkedin.com/in/lorenzo-zaccagnini/">Lorenzo Zaccagnini</a> or <a href="https://www.linkedin.com/in/elisa-romondia/">Elisa Romondia</a> on LinkedIn. If you want to support me you can donate eth or matic to 0xbf8d0d4be61De94EFCCEffbe5D414f911F11cBF8</p>
]]></description><media:thumbnail url="https://lorenzozaccagnini.github.io/images/post_pics/evm-intercept.jpg"/></item><item><title>Develop an Ethereum bridge with Rust</title><link>https://lorenzozaccagnini.github.io/posts/evm-blockchain-rust-bridge/</link><pubDate>Mon, 14 Nov 2022 00:03:47 +0200</pubDate><guid>https://lorenzozaccagnini.github.io/posts/evm-blockchain-rust-bridge/</guid><description><![CDATA[<p>A blockchain bridge is a system that allows the transfer of assets between two different blockchains. It is a crucial component of the blockchain ecosystem as it allows the interoperability of different blockchains. In this article, we will develop a bridge between two EVM-compatible blockchains. We will use the Rust programming language.</p>
<p>Rust is a programming language that is gaining popularity in the blockchain ecosystem. It is a multi-paradigm language that is safe, fast, and concurrent. It is also a systems programming language that is designed to build low-level software. It is a great choice for developing blockchain bridges because of its performance and security.</p>
<h2 id="1-bridges-are-oracles">1. Bridges are oracles</h2>
<p>Bridges are two-way oracles, which means that they can be used to send data from one blockchain to another. The data can be anything, but in this article, we will focus on sending and burning tokens in two different EVM-compatible blockchains.</p>
<p>More information about oracles can be found in my previous article:
<a href="https://lorenzozaccagnini.it/posts/simple-rust-oracle/">Develop an Ethereum oracle with Rust</a></p>
<h2 id="2-a-bridge-architecture">2. A bridge architecture</h2>
<p>The bridge architecture is very simple from a general point of view. It consists of two smart contracts, one on each blockchain. The first contract is called the <strong>bridge contract</strong>. It is deployed on the source blockchain and it is responsible for locking or burning the tokens that need to be transferred. The second contract is called the <strong>destination contract</strong>. It is deployed on the destination blockchain and it is responsible for minting the tokens that need to be transferred. This architecture can work in both directions, but in this article, we will focus on the transfer of tokens from the source blockchain to the destination blockchain.</p>
<h2 id="3-the-bridge-contract">3. The bridge contract</h2>
<p>In this case we will develop a &ldquo;Burn and mint&rdquo; architecture, so the smart contract on the source blockchain will be responsible for burning the tokens that need to be transferred. The smart contract on the destination blockchain will be responsible for minting the tokens that need to be transferred. <strong>Again this can work in both directions</strong>.</p>
<h3 id="31-the-bridge-token">3.1 The bridge token</h3>
<p>The bridge token will be a simple ERC20 token. ERC20 token is a standard for tokens on the Ethereum blockchain. It is a very simple standard that allows the creation of tokens that can be transferred, received, and burned. I will use openzeppelin contracts to develop the bridge token. Openzeppelin is a very popular library for smart contracts development. It contains a lot of useful contracts that can be used to develop smart contracts.</p>
<p>Burning means that the tokens are destroyed. Burning tokens is a very useful feature for a token. It allows the token to be deflationary. Technically means to send the tokens to the address 0x0000000000000000000000000000000000000000. This address is called the zero address and it is a special address that is used to burn tokens. <strong>No one can access the zero address, so the tokens are destroyed forever.</strong></p>
<p>Transferring assets between two blockchains without burning or locking will cause a double spending problem. The double spending problem is a problem that occurs when the same asset is spent more than once. In this case, the asset is the token. If the token is not burned or locked, it can be spent on both blockchains. This will cause a double spending problem and makes the token worthless <strong>like your developer skills.</strong></p>
<p>This will happen with a probability of 101% because bridges are oracles. Oracles are not 101% reliable. They can fail and they often fail. If this bridge fails, the token will be spent on both blockchains and people on twitter will call you a scammer. So if you are a scammer you can skip this step.</p>
<h3 id="32-coding-the-bridge-contract">3.2 Coding the bridge contract</h3>
<p>The smart contract code will be the same on both blockchains, but deployed obviously on both blockchains. The code is very simple and it is composed of two functions: <code>burn</code> and <code>mint</code>. The <code>burn</code> function is responsible for burning the tokens that need to be transferred. The <code>mint</code> function is responsible for minting the tokens that need to be transferred.</p>
<p>Only the owner of the smart contract can call the <code>mint</code> function. The owner of the smart contract is the address that deployed the smart contract. If someone that is not the owner of the smart contract can call the <code>mint</code> function, the bridge will be vulnerable to attacks and people on twitter will call you a scammer, again. So please use a multisig wallet to deploy the smart contract, so people on twitter will not call only you a scammer, but also the other people in the multisig wallet. LGTM.</p>
<p>Please don&rsquo;t be the owner of all the multisig wallets, because people on twitter will call you a scammer and a dictator.</p>
<p>The <code>burn</code> function is responsible for burning the tokens that need to be transferred and can be called by any token holder that has a balance greater than zero.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#ff79c6">pragma solidity</span> <span style="color:#ff79c6">^</span><span style="color:#bd93f9">0</span>.<span style="color:#bd93f9">8</span>.<span style="color:#bd93f9">9</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts@4.8.0/token/ERC20/ERC20.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts@4.8.0/token/ERC20/extensions/ERC20Burnable.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts@4.8.0/access/Ownable.sol&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">contract</span> <span style="color:#50fa7b">GBridgeToken</span> <span style="color:#ff79c6">is</span> ERC20, ERC20Burnable, Ownable {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">constructor</span>() ERC20(<span style="color:#f1fa8c">&#34;gBridgeToken&#34;</span>, <span style="color:#f1fa8c">&#34;GBT&#34;</span>) {
</span></span><span style="display:flex;"><span>        _mint(<span style="color:#8be9fd;font-style:italic">msg</span>.<span style="color:#8be9fd;font-style:italic">sender</span>, <span style="color:#bd93f9">1000</span> <span style="color:#ff79c6">*</span> <span style="color:#bd93f9">10</span><span style="color:#ff79c6">**</span>decimals());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">mint</span>(<span style="color:#8be9fd">address</span> to, <span style="color:#8be9fd">uint256</span> amount) <span style="color:#ff79c6">public</span> onlyOwner {
</span></span><span style="display:flex;"><span>        _mint(to, amount);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The functions with the underscore are inherited from the openzeppelin contracts. The <code>mint</code> function is responsible for minting the tokens. The <code>burn</code> function is responsible for burning the tokens. The <code>onlyOwner</code> modifier is responsible for checking if the caller of the function is the owner of the smart contract. The <code>owner</code> is the address that deployed the smart contract. The <code>msg.sender</code> is the address that called the function.</p>
<p>In the constructor I premint 1000 tokens and I assign them to the address that deployed the smart contract. <strong>This is not necessary, but it is a good practice to premint some tokens to the address that deployed the smart contract.</strong> This will allow the owner of the smart contract to test the bridge before deploying it on the mainnet.</p>
<h2 id="33-deploy-the-bridge-contracts">3.3 Deploy the bridge contracts</h2>
<p>The bridge contracts can be deployed on any EVM-compatible blockchain. In this article, I will deploy the bridge contracts on two local ganache blockchains. One on <code>localhost:8545</code> and one on <code>localhost:7545</code>.</p>
<p>I use remix to connect to the ganache blockchains. Remix is a web IDE for smart contracts development. It is very useful for testing smart contracts. It allows you to connect to different blockchains and to deploy smart contracts. It also allows you to interact with the smart contracts.</p>
<p>Copy the code into remix, compile, select the ganache local chain and deploy the smart contract. If you don&rsquo;t know how to do this you are on the dunning-kruger curve bad side and you should not be developing smart contracts. If you are scammer you can skip this step.</p>
<p>Jokes apart, learn the basics before developing smart contracts and oracles, people can get really angry on twitter.</p>
<h2 id="4-events">4. Events</h2>
<p>Events are a very useful feature of smart contracts. They allow you to log data in the blockchain. The data can be anything, but in this case, we will listen to the transfer event of the bridge token. The transfer event is emitted every time a token is transferred.</p>
<p>If the contracts are deployed correctly you will see transfer events <code>mint</code> or <code>burn</code> are called. The <code>burn</code> event should look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-javascript" data-lang="javascript"><span style="display:flex;"><span><span style="color:#f1fa8c">&#34;topics&#34;</span><span style="color:#ff79c6">:</span> [
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;0x000000000000000000000000399cf2e8d5c14ac04f1599c844a42be4d712b3eb&#34;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#f1fa8c">&#34;0x0000000000000000000000000000000000000000000000000000000000000000&#34;</span>
</span></span><span style="display:flex;"><span>]
</span></span></code></pre></div><p>The event signature for ERC20 transfers, equals sha3(&ldquo;Transfer(address,address,uint256)&rdquo;), to know more about events and topic check my other article <a href="https://lorenzozaccagnini.it/posts/simple-rust-oracle/">Develop an Ethereum oracle with Rust</a></p>
<h2 id="5-the-bridge-rust-code">5. The bridge rust code</h2>
<p>The rust code is in part taken from the article <a href="https://lorenzozaccagnini.it/posts/simple-rust-oracle/">Develop an Ethereum oracle with Rust</a>. The rust code is responsible for listening to the transfer events of the bridge token and for calling the <code>mint</code> function of the bridge contract on the destination blockchain when a transfer event to the zero address (a burn) is detected.</p>
<h3 id="51-the-bridge-crates">5.1 The bridge crates</h3>
<p>This the Cargo.toml file used:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[package]
</span></span><span style="display:flex;"><span>name = <span style="color:#f1fa8c">&#34;blockchain_oracle&#34;</span>
</span></span><span style="display:flex;"><span>version = <span style="color:#f1fa8c">&#34;0.1.0&#34;</span>
</span></span><span style="display:flex;"><span>edition = <span style="color:#f1fa8c">&#34;2021&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[dependencies]
</span></span><span style="display:flex;"><span>web3 = <span style="color:#f1fa8c">&#34;0.17.0&#34;</span>
</span></span><span style="display:flex;"><span>tokio = { version= <span style="color:#f1fa8c">&#34;1&#34;</span>, features = [<span style="color:#f1fa8c">&#34;full&#34;</span>] }
</span></span><span style="display:flex;"><span>hex = <span style="color:#f1fa8c">&#34;0.4.3&#34;</span>
</span></span><span style="display:flex;"><span>ethnum = <span style="color:#f1fa8c">&#34;1.3.0&#34;</span>
</span></span></code></pre></div><ul>
<li><strong>web3</strong> is the crate used to interact with the blockchain.</li>
<li><strong>tokio</strong> is the crate used to run the async code.</li>
<li><strong>hex</strong> is the crate used to convert the bytes to hex. ethnum is the crate used to convert the bytes to u256.</li>
</ul>
<h3 id="52-connecting-to-the-blockchain">5.2 Connecting to the blockchain</h3>
<p>Let&rsquo;s start by connecting to the blockchain.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">use</span> ethnum::U256;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::contract::{Contract, Options};
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::futures::StreamExt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() -&gt; <span style="color:#50fa7b">web3</span>::contract::<span style="color:#8be9fd;font-style:italic">Result</span><span style="color:#ff79c6">&lt;</span>()<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3_source_chain_ws <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        web3::Web3::new(web3::transports::WebSocket::new(<span style="color:#f1fa8c">&#34;ws://localhost:8545&#34;</span>).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The first part imports the crates, the second part is the main function, the third part is the code that connects to the blockchain. The <code>web3_source_chain_ws</code> is the web3 instance used to connect to the source blockchain.</p>
<h3 id="53-listening-to-the-transfer-events">5.3 Listening to the transfer events</h3>
<p>Here I filter and decode the transfer event, dividing the burn and normal transfer events.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">use</span> ethnum::U256;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::contract::{Contract, Options};
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::futures::StreamExt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() -&gt; <span style="color:#50fa7b">web3</span>::contract::<span style="color:#8be9fd;font-style:italic">Result</span><span style="color:#ff79c6">&lt;</span>()<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3_source_chain_ws <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        web3::Web3::new(web3::transports::WebSocket::new(<span style="color:#f1fa8c">&#34;ws://localhost:8545&#34;</span>).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> event_signature <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> source_sc_address <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0xB9d01d2E0FF04A2Ff2f0720Dd69e73F7671b55CE&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> filter_source_transfer <span style="color:#ff79c6">=</span> web3::types::FilterBuilder::default()
</span></span><span style="display:flex;"><span>        .address(vec![source_sc_address.parse().unwrap()])
</span></span><span style="display:flex;"><span>        .from_block(web3::types::BlockNumber::Latest)
</span></span><span style="display:flex;"><span>        .topics(
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">Some</span>(vec![event_signature.parse().unwrap()]),
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .build();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> sub_ganache <span style="color:#ff79c6">=</span> web3_source_chain_ws
</span></span><span style="display:flex;"><span>        .eth_subscribe()
</span></span><span style="display:flex;"><span>        .subscribe_logs(filter_source_transfer)
</span></span><span style="display:flex;"><span>        .<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> sub_ganache_logging <span style="color:#ff79c6">=</span> sub_ganache.for_each(<span style="color:#ff79c6">|</span>log<span style="color:#ff79c6">|</span> <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">move</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> address <span style="color:#ff79c6">=</span> format!(<span style="color:#f1fa8c">&#34;{:?}&#34;</span>, log.clone().unwrap().topics[<span style="color:#bd93f9">2</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">match</span> address.as_str() {
</span></span><span style="display:flex;"><span>            <span style="color:#f1fa8c">&#34;0x0000000000000000000000000000000000000000000000000000000000000000&#34;</span> <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>                println!(<span style="color:#f1fa8c">&#34;Burned&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> amount_decoded <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>                    U256::from_str_radix(<span style="color:#ff79c6">&amp;</span>hex::encode(log.unwrap().data.<span style="color:#bd93f9">0</span>), <span style="color:#bd93f9">16</span>).unwrap();
</span></span><span style="display:flex;"><span>                println!(<span style="color:#f1fa8c">&#34;Amount burned: {}&#34;</span>, amount_decoded);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>                println!(<span style="color:#f1fa8c">&#34;Transferred&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sub_ganache_logging.<span style="color:#ff79c6">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">Ok</span>(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The amount is not indexed so I decode it from the data field. The <code>address</code> is the second topic of the event, is where the token are sent, so I check if it is the zero address to know if it is a burn or a normal transfer.</p>
<p>If everything is working correctly you should see the <code>Burned</code> and <code>Amount burned</code> printed in the console, when you call the <code>burn</code> function on the source blockchain.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Burned
</span></span><span style="display:flex;"><span>Amount burned: 666
</span></span></code></pre></div><h3 id="54-load-the-smart-contract">5.4 Load the smart contract</h3>
<p>Now we can listen, half of the work is done. Now we need to load the smart contract on the destination blockchain. We create a new <code>function mint_tokens</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">mint_tokens</span>(amount: <span style="color:#8be9fd">u64</span>, account_target: <span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd">str</span>, smart_contract_address: <span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd">str</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3_destination_chain <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        web3::Web3::new(web3::transports::Http::new(<span style="color:#f1fa8c">&#34;http://localhost:7545&#34;</span>).unwrap());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3_destination_chain_contract <span style="color:#ff79c6">=</span> Contract::from_json(
</span></span><span style="display:flex;"><span>        web3_destination_chain.eth(),
</span></span><span style="display:flex;"><span>        smart_contract_address.parse().unwrap(),
</span></span><span style="display:flex;"><span>        include_bytes!(<span style="color:#f1fa8c">&#34;GBridgeToken.json&#34;</span>),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .unwrap();
</span></span></code></pre></div><p>The <code>web3_destination_chain_contract</code> is the contract instance on the destination blockchain. The <code>include_bytes!</code> macro is used to include the ABI of the smart contract. The ABI is generated by the <code>solc</code> compiler. The json file is the ABI that is generated by the <code>solc</code> compiler or remix IDE.</p>
<h3 id="55-minting-the-tokens">5.5 Minting the tokens</h3>
<p>Now we can mint the tokens on the destination blockchain when we receive a burn event on the source blockchain.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">mint_tokens</span>(amount: <span style="color:#8be9fd">u64</span>, account_target: <span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd">str</span>, smart_contract_address: <span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd">str</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3_destination_chain <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        web3::Web3::new(web3::transports::Http::new(<span style="color:#f1fa8c">&#34;http://localhost:7545&#34;</span>).unwrap());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3_destination_chain_contract <span style="color:#ff79c6">=</span> Contract::from_json(
</span></span><span style="display:flex;"><span>        web3_destination_chain.eth(),
</span></span><span style="display:flex;"><span>        smart_contract_address.parse().unwrap(),
</span></span><span style="display:flex;"><span>        include_bytes!(<span style="color:#f1fa8c">&#34;GBridgeToken.json&#34;</span>),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .unwrap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> ganache_accounts <span style="color:#ff79c6">=</span> web3_destination_chain.eth().accounts().<span style="color:#ff79c6">await</span>.unwrap();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> account <span style="color:#ff79c6">=</span> ganache_accounts[<span style="color:#bd93f9">0</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//convert account_target to address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">let</span> account_target_address <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        web3::types::Address::from_slice(<span style="color:#ff79c6">&amp;</span>hex::decode(account_target.replace(<span style="color:#f1fa8c">&#34;0x&#34;</span>, <span style="color:#f1fa8c">&#34;&#34;</span>)).unwrap());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    web3_destination_chain_contract
</span></span><span style="display:flex;"><span>        .call(
</span></span><span style="display:flex;"><span>            <span style="color:#f1fa8c">&#34;mint&#34;</span>,
</span></span><span style="display:flex;"><span>            (account_target_address, amount),
</span></span><span style="display:flex;"><span>            account,
</span></span><span style="display:flex;"><span>            Options::default(),
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .<span style="color:#ff79c6">await</span>
</span></span><span style="display:flex;"><span>        .unwrap();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>First I get the accounts from the destination blockchain, then I convert the <code>account_target</code> to an address. The <code>account_target</code> sends token to the same address on the destination blockchain.</p>
<p>The <code>account</code> is the account that will call the <code>mint</code> function, it should be the owner of the smart contract on the destination blockchain. The <code>Options::default()</code> is used to set the gas price and gas limit. The <code>web3_destination_chain_contract.call</code> is used to call the <code>mint</code> function.</p>
<p>The <code>amount</code> is the amount of tokens that will be minted on the destination blockchain, it is same quantity of the burned tokens on the source blockchain.</p>
<p>If you see the token balance of the <code>account_target</code> on the destination blockchain, you should see the added the amount of tokens that you burned on the source blockchain.</p>
<h3 id="56-putting-it-all-together">5.6 Putting it all together</h3>
<p>Now we can put it all together. We need to listen to the transfer events on the source blockchain and mint the tokens on the destination blockchain.</p>
<p>All the code can be found in this <a href="https://github.com/LorenzoZaccagnini/EVM-blockchain-rust-bridge">GitHub repository</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">use</span> ethnum::U256;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::contract::{Contract, Options};
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::futures::StreamExt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() -&gt; <span style="color:#50fa7b">web3</span>::contract::<span style="color:#8be9fd;font-style:italic">Result</span><span style="color:#ff79c6">&lt;</span>()<span style="color:#ff79c6">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3_source_chain_ws <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        web3::Web3::new(web3::transports::WebSocket::new(<span style="color:#f1fa8c">&#34;ws://localhost:8545&#34;</span>).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> event_signature <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> source_sc_address <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0xB9d01d2E0FF04A2Ff2f0720Dd69e73F7671b55CE&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> destionation_sc_address <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0x4641B307794E29062906dc5fEd72152faEBB1C77&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> filter_source_transfer <span style="color:#ff79c6">=</span> web3::types::FilterBuilder::default()
</span></span><span style="display:flex;"><span>        .address(vec![source_sc_address.parse().unwrap()])
</span></span><span style="display:flex;"><span>        .from_block(web3::types::BlockNumber::Latest)
</span></span><span style="display:flex;"><span>        .topics(
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">Some</span>(vec![event_signature.parse().unwrap()]),
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .build();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> sub_ganache <span style="color:#ff79c6">=</span> web3_source_chain_ws
</span></span><span style="display:flex;"><span>        .eth_subscribe()
</span></span><span style="display:flex;"><span>        .subscribe_logs(filter_source_transfer)
</span></span><span style="display:flex;"><span>        .<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> sub_ganache_logging <span style="color:#ff79c6">=</span> sub_ganache.for_each(<span style="color:#ff79c6">|</span>log<span style="color:#ff79c6">|</span> <span style="color:#ff79c6">async</span> <span style="color:#ff79c6">move</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> address <span style="color:#ff79c6">=</span> format!(<span style="color:#f1fa8c">&#34;{:?}&#34;</span>, log.clone().unwrap().topics[<span style="color:#bd93f9">2</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> address_from_raw <span style="color:#ff79c6">=</span> format!(<span style="color:#f1fa8c">&#34;{:?}&#34;</span>, log.clone().unwrap().topics[<span style="color:#bd93f9">1</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">let</span> address_from_decoded <span style="color:#ff79c6">=</span> format!(<span style="color:#f1fa8c">&#34;0x{}&#34;</span>, <span style="color:#ff79c6">&amp;</span>address_from_raw[<span style="color:#bd93f9">26</span><span style="color:#ff79c6">..</span><span style="color:#bd93f9">66</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">match</span> address.as_str() {
</span></span><span style="display:flex;"><span>            <span style="color:#f1fa8c">&#34;0x0000000000000000000000000000000000000000000000000000000000000000&#34;</span> <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>                println!(<span style="color:#f1fa8c">&#34;Burned&#34;</span>);
</span></span><span style="display:flex;"><span>                <span style="color:#8be9fd;font-style:italic">let</span> amount_decoded <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>                    U256::from_str_radix(<span style="color:#ff79c6">&amp;</span>hex::encode(log.clone().unwrap().data.<span style="color:#bd93f9">0</span>), <span style="color:#bd93f9">16</span>).unwrap();
</span></span><span style="display:flex;"><span>                println!(<span style="color:#f1fa8c">&#34;Amount burned: {}&#34;</span>, amount_decoded);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#6272a4">//mint tokens on the destination chain
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>                mint_tokens(
</span></span><span style="display:flex;"><span>                    amount_decoded.as_u64(),
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">&amp;</span>address_from_decoded,
</span></span><span style="display:flex;"><span>                    <span style="color:#ff79c6">&amp;</span>destionation_sc_address,
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>                .<span style="color:#ff79c6">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                println!(<span style="color:#f1fa8c">&#34;Burned from: {}&#34;</span>, address_from_decoded);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            _ <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>                println!(<span style="color:#f1fa8c">&#34;Transferred&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    sub_ganache_logging.<span style="color:#ff79c6">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">Ok</span>(())
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">mint_tokens</span>(amount: <span style="color:#8be9fd">u64</span>, account_target: <span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd">str</span>, smart_contract_address: <span style="color:#ff79c6">&amp;</span><span style="color:#8be9fd">str</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3_destination_chain <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        web3::Web3::new(web3::transports::Http::new(<span style="color:#f1fa8c">&#34;http://localhost:7545&#34;</span>).unwrap());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3_destination_chain_contract <span style="color:#ff79c6">=</span> Contract::from_json(
</span></span><span style="display:flex;"><span>        web3_destination_chain.eth(),
</span></span><span style="display:flex;"><span>        smart_contract_address.parse().unwrap(),
</span></span><span style="display:flex;"><span>        include_bytes!(<span style="color:#f1fa8c">&#34;GBridgeToken.json&#34;</span>),
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    .unwrap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> ganache_accounts <span style="color:#ff79c6">=</span> web3_destination_chain.eth().accounts().<span style="color:#ff79c6">await</span>.unwrap();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> account <span style="color:#ff79c6">=</span> ganache_accounts[<span style="color:#bd93f9">0</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//convert account_target to address
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">let</span> account_target_address <span style="color:#ff79c6">=</span>
</span></span><span style="display:flex;"><span>        web3::types::Address::from_slice(<span style="color:#ff79c6">&amp;</span>hex::decode(account_target.replace(<span style="color:#f1fa8c">&#34;0x&#34;</span>, <span style="color:#f1fa8c">&#34;&#34;</span>)).unwrap());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    web3_destination_chain_contract
</span></span><span style="display:flex;"><span>        .call(
</span></span><span style="display:flex;"><span>            <span style="color:#f1fa8c">&#34;mint&#34;</span>,
</span></span><span style="display:flex;"><span>            (account_target_address, amount),
</span></span><span style="display:flex;"><span>            account,
</span></span><span style="display:flex;"><span>            Options::default(),
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .<span style="color:#ff79c6">await</span>
</span></span><span style="display:flex;"><span>        .unwrap();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I&rsquo;ve added the mint function to the main function when a burn event is detected. The <code>mint_tokens</code> function is the same as the one we used in the previous section.</p>
<h2 id="6-aggregate-transactions-on-a-bridge-oracle">6. Aggregate transactions on a bridge oracle</h2>
<p>An efficient bridge oracle will aggregate the transactions before sending them to the destination blockchain. It&rsquo;s really important to aggregate the transactions because it will reduce the gas cost and the transaction fees, imagine a bridge oracle use thousand of times every day that will send a transaction for each transfer event, it will be really expensive.</p>
<p>In order to do that is possible to use data structure like a Merkle tree. A Merkle tree is a data structure that allows to aggregate the transactions and verify the aggregated transactions. In the future we will see the use of Verkle trees that are more efficient than Merkle trees. Maybe this topic will be covered in a future article.</p>
<h2 id="7-do-you-need-to-develop-an-oracle-or-a-bridge">7. Do you need to develop an oracle or a bridge?</h2>
<p>You can contact me <a href="https://www.linkedin.com/in/lorenzo-zaccagnini/">Lorenzo Zaccagnini</a> or <a href="https://www.linkedin.com/in/elisa-romondia/">Elisa Romondia</a> on LinkedIn. If you want to support me you can donate eth or matic to 0xbf8d0d4be61De94EFCCEffbe5D414f911F11cBF8</p>
]]></description><media:thumbnail url="https://lorenzozaccagnini.github.io/images/post_pics/rust_evm_bridge.jpg"/></item><item><title>Develop an Ethereum oracle with Rust</title><link>https://lorenzozaccagnini.github.io/posts/simple-rust-oracle/</link><pubDate>Sat, 22 Oct 2022 00:03:47 +0200</pubDate><guid>https://lorenzozaccagnini.github.io/posts/simple-rust-oracle/</guid><description><![CDATA[<p>A blockchain oracle is a service that allows smart contracts to interact with external data sources. In this post, we will develop a simple oracle that will track every time a <a href="https://etherscan.io/address/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85">Ethereum Name Service NFT</a> is transferred. We will use Rust and the web3 crate to interact with the Ethereum blockchain.</p>
<p>Stay with me until the end to learn how to listen to events on the Ethereum blockchain, you will learn how events work and how to use them in your smart contracts and oracles. Interoperability is a key feature of the Ethereum blockchain, and oracles are a key component of this interoperability.</p>
<h2 id="1-why-blockchains-cant-access-external-data-sources">1. Why blockchains can&rsquo;t access external data sources</h2>
<p>Blockchains can&rsquo;t access external data sources natively because it is a deterministic system. Each node in the network has a copy of the blockchain, they must all agree on the same state. If a smart contract was able to access external data sources, it would break the deterministic nature of the blockchain. The verification of the state of the blockchain would be impossible, remember same inputs always produce the same outputs.</p>
<p>We can solve this problem by using a blockchain oracle. A blockchain oracle is a service that allows smart contracts to interact with external data sources. The oracle will be responsible for fetching the external data and sending it to the smart contract. The smart contract will then be able to access the data.</p>
<p>Let&rsquo;s make an example to illustrate this. Let&rsquo;s say we have a smart contract that stores the current price of a cryptocurrency. If the price of the cryptocurrency is updated every 10 seconds on an external API, the smart contract will have to be updated every 10 seconds, otherwise the smart contract will be out of sync. It would impossible for others to verify the state of the blockchain.</p>
<p>This is why blockchains need oracles, external data must be fed into the blockchain with a transaction, in this way all nodes in the network will have the same data and the blockchain will remain deterministic.</p>
<p><a href="https://ethereum.stackexchange.com/questions/301/why-cant-contracts-make-api-calls">Read this fantastic answer on StackOverflow to learn more about that</a></p>
<p>In my experience I&rsquo;ve developed many blockchain oracles, for our project Devoleum and for many other projects. I&rsquo;ve used different languages but Rust is the one that I love the most. I&rsquo;ve developed oracles for various use cases:</p>
<ul>
<li>Crosschain bridges</li>
<li>Connecting IoT to the Ethereum blockchain</li>
<li>Display data from the blockchain for a frontend that does not have access to the blockchain via a browser wallet like metamask.</li>
</ul>
<h2 id="2-what-is-an-oracle">2. What is an oracle?</h2>
<p>Most of the time is a simple service that listens to events on the blockchain and updates the state of the smart contract. It can also be a smart contract that is called by other smart contracts to get external data. In this article we will develop a simple service that will listen to events on the ethereum blockchain, more precisely the transfer event of ENS NFTs.</p>
<p>Different types of oracles exist, some of them are:</p>
<ul>
<li><strong>Inbound oracles</strong>: they listen to events on the blockchain</li>
<li><strong>Outbound oracles</strong>: they send transactions to the blockchain</li>
<li><strong>Hybrid oracles</strong>: they listen to events on the blockchain and send transactions to the blockchain</li>
</ul>
<h2 id="3-setup-the-ethereum-oracle-project">3. Setup the ethereum oracle project</h2>
<p>We will develop a simple oracle that will listen to the transfer event of ENS NFTs. We will use Rust and the web3 crate to interact with the Ethereum blockchain. We will use the Alchemy API to interact with the Ethereum blockchain, otherwise it will be necessary to run a full node.</p>
<p>All the code of this article is available on <a href="https://github.com/LorenzoZaccagnini/simple-rust-ethereum-inbound-oracle">Github</a>.</p>
<h3 id="31-install-rust">3.1. Install Rust</h3>
<p>If you don&rsquo;t have Rust installed on your machine, you can follow the <a href="https://www.rust-lang.org/tools/install">official installation guide</a>.</p>
<h3 id="32-create-a-new-project">3.2. Create a new project</h3>
<p>We will use the cargo command to create a new project. Cargo is the Rust package manager and build system.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cargo new simple-rust-oracle
</span></span></code></pre></div><h3 id="33-add-the-dependencies">3.3. Add the dependencies</h3>
<p>We will add the web3 and other dependencies to our <strong>Cargo.toml</strong> file:</p>
<ul>
<li><strong>Web3</strong> crate is a Rust library for interacting with Ethereum and other blockchain nodes. It provides a full set of features for interacting with the blockchain, including sending transactions, reading data from the blockchain, and listening to events.</li>
<li><strong>Tokio</strong> is a runtime for asynchronous Rust applications.</li>
<li>The <strong>dotenv</strong> crate is used to load environment variables from a .env file, we&rsquo;ll use it to load our Alchemy API key without hardcoding it in our code (and exposing it to the world).</li>
<li><strong>Ethnum</strong> is used to handle big unsigned integers.</li>
</ul>
<p>This is how our <strong>Cargo.toml</strong> file should look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>[dependencies]
</span></span><span style="display:flex;"><span>web3 = <span style="color:#f1fa8c">&#34;0.17.0&#34;</span>
</span></span><span style="display:flex;"><span>tokio = { version= <span style="color:#f1fa8c">&#34;1&#34;</span>, features = [<span style="color:#f1fa8c">&#34;full&#34;</span>] }
</span></span><span style="display:flex;"><span>dotenv = <span style="color:#f1fa8c">&#34;0.15.0&#34;</span>
</span></span><span style="display:flex;"><span>ethnum = <span style="color:#f1fa8c">&#34;1.3.0&#34;</span>
</span></span></code></pre></div><h3 id="34-create-a-env-file">3.4. Create a .env file</h3>
<p>We will create a .env file at the root of our project. We will store our <a href="https://www.alchemy.com/">Alchemy API key</a> in this file and load it with the dotenv crate.</p>
<p>You can use <a href="https://infura.io/">Infura</a> instead of Alchemy, just replace the Alchemy API key with your Infura API key.</p>
<p>In both cases you have to signup to get an API key. <strong>I will use the mainnet API key</strong> to listen to the ENS NFTs transfer events. You can use the testnet API key if you want to test the oracle on the testnet.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>touch .env
</span></span></code></pre></div><p>The .env file should look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">ALCHEMY_API_KEY</span><span style="color:#ff79c6">=</span>wss://eth-mainnet.g.alchemy.com/v2/S0meR4nd0mStr1ng
</span></span></code></pre></div><h2 id="4-develop-the-ethereum-oracle">4. Develop the ethereum oracle</h2>
<h3 id="41-load-the-environment-variables">4.1. Load the environment variables</h3>
<p>We will load the environment variables with the dotenv crate. We will use the <strong>dotenv::dotenv()</strong> function to load the environment variables from the .env file. We will use the <strong>dotenv::var()</strong> function to get the value of a specific environment variable.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> dotenv::dotenv;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    dotenv().ok();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> alchemy_api_key <span style="color:#ff79c6">=</span> dotenv::var(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="42-connect-to-the-ethereum-blockchain">4.2. Connect to the Ethereum blockchain</h3>
<p>We will use the web3 crate and the Alchemy API to connect to the Ethereum blockchain.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">use</span> dotenv::dotenv;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() {
</span></span><span style="display:flex;"><span>    dotenv().ok();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> alchemy_api_key <span style="color:#ff79c6">=</span> dotenv::var(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3 <span style="color:#ff79c6">=</span> web3::Web3::new(web3::transports::Http::new(<span style="color:#ff79c6">&amp;</span>alchemy_api_key).unwrap());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="43-filter-to-the-ens-nfts-transfer-events">4.3. Filter to the ENS NFTs transfer events</h3>
<p>We need to know the ENS smart contract address to listen to the transfer events. We can find the address of the ENS smart contract on <a href="https://etherscan.io/address/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85#code">Etherscan</a>.</p>
<p><strong>WAIT!</strong> We want to listen to a specific event, not to every event of the smart contract so we need to know the event signature. The event signature is the hash of the event name and the event parameters.</p>
<p>Signature or topic0 = 0x + keccak256(&ldquo;Transfer(address,address,uint256)&rdquo;))</p>
<p>0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef = Transfer(address,address,uint256)</p>
<p>As you can see here on <a href="https://etherscan.io/address/0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85#events">Etherscan</a> the event signature is 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.</p>
<p><img src="/images/post_pics/simple_rust_oracle/eventetherscan.jpg" alt=""></p>
<p>Let&rsquo;s code it!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">use</span> dotenv::dotenv;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() -&gt; <span style="color:#8be9fd;font-style:italic">Result</span><span style="color:#ff79c6">&lt;</span>(), <span style="color:#8be9fd;font-style:italic">Box</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">dyn</span> std::error::Error<span style="color:#ff79c6">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    dotenv().ok();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> alchemy_api_key <span style="color:#ff79c6">=</span> dotenv::var(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3 <span style="color:#ff79c6">=</span> web3::Web3::new(web3::transports::WebSocket::new(<span style="color:#ff79c6">&amp;</span>alchemy_api_key).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> contract_address <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> event_signature <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> filter <span style="color:#ff79c6">=</span> web3::types::FilterBuilder::default()
</span></span><span style="display:flex;"><span>        .address(vec![contract_address.parse().unwrap()])
</span></span><span style="display:flex;"><span>        .from_block(web3::types::BlockNumber::Latest)
</span></span><span style="display:flex;"><span>        .topics(
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">Some</span>(vec![event_signature.parse().unwrap()]),
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .build();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">Ok</span>(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As you can read I set the contract address and the event signature. I also wrote the filter to listen to the latest block. The filter contains the contract address and the event signature. Note that I&rsquo;ve used the <strong>topics</strong> function to filter to the specific event and Tokio to run the code asynchronously.</p>
<h3 id="44-listen-and-print-the-ethereum-ens-transfer-events">4.4. Listen and print the Ethereum ENS transfer events</h3>
<p>Now we need to subscribe to the filter and listen to the events. We will use the <strong>web3.eth_subscribe()</strong> function to subscribe to the filter. We will use the <strong>web3::types::Log</strong> struct to decode the event data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">use</span> dotenv::dotenv;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::futures::{future, StreamExt};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() -&gt; <span style="color:#8be9fd;font-style:italic">Result</span><span style="color:#ff79c6">&lt;</span>(), <span style="color:#8be9fd;font-style:italic">Box</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">dyn</span> std::error::Error<span style="color:#ff79c6">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    dotenv().ok();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> alchemy_api_key <span style="color:#ff79c6">=</span> dotenv::var(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3 <span style="color:#ff79c6">=</span> web3::Web3::new(web3::transports::WebSocket::new(<span style="color:#ff79c6">&amp;</span>alchemy_api_key).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> contract_address <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> event_signature <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> filter <span style="color:#ff79c6">=</span> web3::types::FilterBuilder::default()
</span></span><span style="display:flex;"><span>        .address(vec![contract_address.parse().unwrap()])
</span></span><span style="display:flex;"><span>        .from_block(web3::types::BlockNumber::Latest)
</span></span><span style="display:flex;"><span>        .topics(
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">Some</span>(vec![event_signature.parse().unwrap()]),
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .build();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> transfer_listen <span style="color:#ff79c6">=</span> web3.eth_subscribe().subscribe_logs(filter).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    transfer_listen
</span></span><span style="display:flex;"><span>        .for_each(<span style="color:#ff79c6">|</span>log<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>            println!(<span style="color:#f1fa8c">&#34;log: {:?}&#34;</span>, log);
</span></span><span style="display:flex;"><span>            future::ready(())
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        .<span style="color:#ff79c6">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">Ok</span>(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I&rsquo;ve used <strong>future::ready</strong> to run the code asynchronously. I&rsquo;ve also used the <strong>for_each</strong> function to iterate over the events.</p>
<p><strong>The result should be this:</strong></p>
<p><img src="/images/post_pics/simple_rust_oracle/transferlog.jpg" alt=""></p>
<h3 id="45-decode-the-event-data">4.5. Decode the event data</h3>
<p>We need to decode the event data to get the transfer details. First, we import ethnum, after we decode the event data in the <strong>transfer_listen</strong> loop. We get the hex string of token id from the fourth topic, after I use <strong>from_str_radix()</strong> from <strong>ethnum</strong> to convert the hex string to a U256.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#ff79c6">use</span> dotenv::dotenv;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> ethnum::U256;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">use</span> web3::futures::{future, StreamExt};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">#[tokio::main]</span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">async</span> <span style="color:#ff79c6">fn</span> <span style="color:#50fa7b">main</span>() -&gt; <span style="color:#8be9fd;font-style:italic">Result</span><span style="color:#ff79c6">&lt;</span>(), <span style="color:#8be9fd;font-style:italic">Box</span><span style="color:#ff79c6">&lt;</span><span style="color:#ff79c6">dyn</span> std::error::Error<span style="color:#ff79c6">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    dotenv().ok();
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> alchemy_api_key <span style="color:#ff79c6">=</span> dotenv::var(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY&#34;</span>).expect(<span style="color:#f1fa8c">&#34;ALCHEMY_API_KEY must be set&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> web3 <span style="color:#ff79c6">=</span> web3::Web3::new(web3::transports::WebSocket::new(<span style="color:#ff79c6">&amp;</span>alchemy_api_key).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> contract_address <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0x57f1887a8bf19b14fc0df6fd9b2acc9af147ea85&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> event_signature <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> filter <span style="color:#ff79c6">=</span> web3::types::FilterBuilder::default()
</span></span><span style="display:flex;"><span>        .address(vec![contract_address.parse().unwrap()])
</span></span><span style="display:flex;"><span>        .from_block(web3::types::BlockNumber::Latest)
</span></span><span style="display:flex;"><span>        .topics(
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">Some</span>(vec![event_signature.parse().unwrap()]),
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">None</span>,
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>        .build();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">let</span> transfer_listen <span style="color:#ff79c6">=</span> web3.eth_subscribe().subscribe_logs(filter).<span style="color:#ff79c6">await</span><span style="color:#ff79c6">?</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    transfer_listen
</span></span><span style="display:flex;"><span>        .for_each(<span style="color:#ff79c6">|</span>log<span style="color:#ff79c6">|</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">let</span> id <span style="color:#ff79c6">=</span> format!(<span style="color:#f1fa8c">&#34;{:?}&#34;</span>, log.unwrap().topics[<span style="color:#bd93f9">3</span>]);
</span></span><span style="display:flex;"><span>            println!(<span style="color:#f1fa8c">&#34;id NOT decoded: {:?}&#34;</span>, id);
</span></span><span style="display:flex;"><span>            <span style="color:#8be9fd;font-style:italic">let</span> id_decoded <span style="color:#ff79c6">=</span> U256::from_str_radix(<span style="color:#ff79c6">&amp;</span>id[<span style="color:#bd93f9">2</span><span style="color:#ff79c6">..</span>], <span style="color:#bd93f9">16</span>).unwrap();
</span></span><span style="display:flex;"><span>            println!(<span style="color:#f1fa8c">&#34;id decoded: {:?}&#34;</span>, id_decoded);
</span></span><span style="display:flex;"><span>            println!(<span style="color:#f1fa8c">&#34;----------&#34;</span>);
</span></span><span style="display:flex;"><span>            future::ready(())
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        .<span style="color:#ff79c6">await</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">Ok</span>(())
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>The result should be this:</strong></p>
<p><img src="/images/post_pics/simple_rust_oracle/transferid.jpg" alt=""></p>
<h2 id="5-do-you-need-to-develop-an-oracle-or-a-bridge">5. Do you need to develop an oracle or a bridge?</h2>
<p>You can contact me <a href="https://www.linkedin.com/in/lorenzo-zaccagnini/">Lorenzo Zaccagnini</a> or <a href="https://www.linkedin.com/in/elisa-romondia/">Elisa Romondia</a> on LinkedIn. If you want to support me you can donate eth or matic to 0xbf8d0d4be61De94EFCCEffbe5D414f911F11cBF8</p>
]]></description><media:thumbnail url="https://lorenzozaccagnini.github.io/images/post_pics/oraclecover.jpg"/></item><item><title>About</title><link>https://lorenzozaccagnini.github.io/pages/about/</link><pubDate>Tue, 16 Aug 2022 00:03:47 +0200</pubDate><guid>https://lorenzozaccagnini.github.io/pages/about/</guid><description><![CDATA[<h2 id="who-is-lorenzo-thorrwulf-zaccagnini">Who is Lorenzo &lsquo;Thorrwulf&rsquo; Zaccagnini</h2>
<p>Smart contract auditor and cryptography nerd, follow me on my Twitch channel Thorrwulf. It&rsquo;s possible to contact me on Telegram at <a href="https://t.me/Thorrwulf">@Thorrwulf</a>.</p>
<p>I built my first p2p client and hub at 14y in C++, now I prefer Rust. The long part…</p>
<p>I&rsquo;ve years of experience in teaching and developing web apps (front and backend in Javascript), and decentralized apps on EVM blockchains like Ethereum. I have extensive knowledge about vulnerabilities of smart contracts and web apps, my analysis and audits often appear in national and international media, with topics ranging from contact tracing apps to DAOs NFTs Oracles, and Defi projects. I&rsquo;m the co-founder of Devoleum, a web app that uses blockchains and linked open data to make supply chain data open and traceable, our project is internationally awarded by Forbes USA and many others. In 2016 I have won a national hackathon with an app about geo tracing using e2e cryptography design. I have a Psychology MSc. I&rsquo;m a privacy and diversity activist.</p>
<h3 id="honours-awards-publications">HONOURS, AWARDS, PUBLICATIONS</h3>
<p><strong>October 2021 - HP Anche Hitler col Green Pass dopo un attacco hacker. Ma già non funziona più (L. Bianchi)</strong></p>
<p><a href="https://www.huffingtonpost.it/entry/green-pass-attacco-hacker-sottrae-le-chiavi-per-generarlo-ma-lallarme-dura-poco_it_61792986e4b079111a5eb6a5">https://www.huffingtonpost.it/entry/green-pass-attacco-hacker-sottrae-le-chiavi-per-generarlo-ma-lallarme-dura-poco_it_61792986e4b079111a5eb6a5</a></p>
<p><strong>April 2021 - Exchange, hacker e annunci di nuove tasse: dilaga il panico nel mondo delle criptovalute (N. Borzi)</strong></p>
<p><a href="https://www.ilfattoquotidiano.it/in-edicola/articoli/2021/04/26/exchange-attacchi-hacker-e-annunci-di-nuove-tasse-un-tremito-scuote-il-mondo-delle-criptovalute">https://www.ilfattoquotidiano.it/in-edicola/articoli/2021/04/26/exchange-attacchi-hacker-e-annunci-di-nuove-tasse-un-tremito-scuote-il-mondo-delle-criptovalute</a></p>
<p><strong>May 2021 - Blockchain Technology and Sustainable Business Models:</strong></p>
<p>A Case Study of Devoleum - published paper
<a href="https://doi.org/10.3390/su13105619">https://doi.org/10.3390/su13105619</a></p>
<p><strong>April 2020 - FQ Article about Italian contact tracing app issues (N. Borzi)</strong></p>
<p>Italian contact tracing app privacy and cybersecurity issues
<a href="https://www.ilfattoquotidiano.it/in-edicola/articoli/2020/04/23/ombre-e-problemi-della-app-con-cui-vogliono-tracciarci/5779330/">https://www.ilfattoquotidiano.it/in-edicola/articoli/2020/04/23/ombre-e-problemi-della-app-con-cui-vogliono-tracciarci/5779330/</a></p>
<p><strong>April 2020 - Healthcare data economy (N. Borzi)</strong></p>
<p>Article about the privacy issues in the healthcare data trading sector
<a href="https://valori.it/emergenza-sanitaria-apre-data-economy/">https://valori.it/emergenza-sanitaria-apre-data-economy/</a></p>
<p><strong>November 2019 - Strategy Innovation Forum</strong></p>
<p>Selected as a speaker for the Blockchain and AI supply chain sector, at the University of Venice Ca&rsquo; Foscari
<a href="https://www.unive.it/pag/34335/">https://www.unive.it/pag/34335/</a></p>
<p><strong>April 2019 - Italian Chamber of Deputies</strong></p>
<p>Invited as a Speaker about &ldquo;Managing big streams of Data using Blockchain and AI&rdquo;
<a href="https://www.youtube.com/watch?v=xOobvSzjPxE">https://www.youtube.com/watch?v=xOobvSzjPxE</a></p>
<p><strong>September 2018 - 60 Women-Led Startups That Are Shaking Up Tech Across The Globe</strong></p>
<p>Devoleum is mentioned in the Forbes top 60 startups worldwide
<a href="https://www.forbes.com/sites/allysonkapin/2018/09/19/60-women-led-startups-who-are-shaking-up-">https://www.forbes.com/sites/allysonkapin/2018/09/19/60-women-led-startups-who-are-shaking-up-</a> tech-across-the-globe/#1bf7fa4075da</p>
<p><strong>February 2018 - Scholarship winner | Google Developer Challenge, Mobile Web Specialist Nanodegree by Google e Udacity</strong></p>
<p><a href="https://www.udacity.com/course/mobile-web-specialist-nanodegree--nd024">https://www.udacity.com/course/mobile-web-specialist-nanodegree--nd024</a>
Selected by Google and Udacity for my coding skills among more than 200,000 candidate developers.</p>
<p><strong>December 2017 - Press about Devoleum, Il Messaggero newspaper, excellence of the Universities of Rome</strong></p>
<p><a href="http://www.ilmessaggero.it/roma/cronaca/roma_laureati_con_il_pollice_verde_start_up_e_rob">http://www.ilmessaggero.it/roma/cronaca/roma_laureati_con_il_pollice_verde_start_up_e_rob</a> ot_per_i_campi_con_l_universita_il_lavoro_e_bio-3454639.html
&ldquo;Con la startup dei due giovani (riconosciuta anche a Parigi), invece, anche i piccoli produttori potranno certificare in maniera chiara ed onesta i loro prodotti&rdquo; Camilla Mozzetti</p>
<p><strong>December 2017 - Press | RTL interview about Devoleum</strong></p>
<p><a href="https://www.youtube.com/watch?v=77fMsOpNMm4">https://www.youtube.com/watch?v=77fMsOpNMm4</a>
Interview with Fulvio Giuliani.</p>
<p><strong>November 2017 - Press L&rsquo;Usine Nouvelle about Devoleum</strong></p>
<p><a href="https://www.usinenouvelle.com/article/les-reseaux-se-mobilisent-pour-promouvoir-les-">https://www.usinenouvelle.com/article/les-reseaux-se-mobilisent-pour-promouvoir-les-</a> femmes-dans-le-numerique-pour-quel-resultat.N619018
&ldquo;des expertes en technologie, telle la développeuse Élisa Romondia, qui a cofondé Devoleum, une marketplace italienne utilisant la blockchain pour certifier et commercialiser des huiles d’olive produites localement.&rdquo; Marion Garreau</p>
<p><strong>October 2017 - Press Business Insider about Devoleum</strong></p>
<p><a href="http://www.businessinsider.fr/startups-finalistes-starther-awards-2017?lipi=urn%253Ali">http://www.businessinsider.fr/startups-finalistes-starther-awards-2017?lipi=urn%253Ali</a> %253Apage%253Ad_flagship3_profile_view_base_treasury %253Bm4k7Ost8QOCNu7D5y4SfXQ%253D%253D
&ldquo;Devoleum (Italie), cofondé par Elisa Romondia — Marketplace utilisant la Blockchain afin de certifier et de commercialiser des huiles d’olives produites localement&rdquo; Marie-Catherine Beuth</p>
<p><strong>October 2017 - Press Forbes about Devoleum</strong></p>
<p><a href="https://www.forbes.fr/femmes-at-forbes/starther-awards-la-start-up-medtech-novagray-remporte-le-concours/?lipi=urn%253Ali%253Apage%253Ad_flagship3_profile_view_base_treasury">https://www.forbes.fr/femmes-at-forbes/starther-awards-la-start-up-medtech-novagray-remporte-le-concours/?lipi=urn%253Ali%253Apage%253Ad_flagship3_profile_view_base_treasury</a> %253BrIEP4cANTgWZ0zZMyCAGdw%253D%253D
&ldquo;utiliser la Blockchain pour certifier et commercialiser les huiles d’olives produites localement.&rdquo; Audrey Chabal</p>
<p><strong>October 2017 - Press Le Figaro about Devoleum</strong></p>
<p><a href="http://www.lefigaro.fr/secteur/high-tech/start-up/2017/10/20/32004-20171020ARTFIG00341-qui-est-derriere-novagray-la-start-up-recompensee-par-le-prix-starther.php?lipi=urn%253Ali%253Apage%253Ad_flagship3_profile_view_base_treasury%253BfzIB4H%252F1Q9aw6lrtcA7p7Q%253D">http://www.lefigaro.fr/secteur/high-tech/start-up/2017/10/20/32004-20171020ARTFIG00341-qui-est-derriere-novagray-la-start-up-recompensee-par-le-prix-starther.php?lipi=urn%253Ali%253Apage%253Ad_flagship3_profile_view_base_treasury%253BfzIB4H%252F1Q9aw6lrtcA7p7Q%253D</a> %253D
&ldquo;Cette technologie très sophistiquée est également au cœur du projet d&rsquo;Elisa Romondia, développe use de Devoleum, afin de certifier l&rsquo;origine des huiles d&rsquo;olive de son Italie natale&rdquo; Elisa Braun</p>
<p><strong>October 2017 - Devoleum presented at the Station F</strong></p>
<p><a href="https://www.youtube.com/watch?v=XCjEvEGdjL0">https://www.youtube.com/watch?v=XCjEvEGdjL0</a>
Devoleum has been selected from hundreds of European projects to take part in the 2017 StartHer Awards, held at Station F in Paris, the world&rsquo;s largest Campus startup, home to Google and Facebook. The event was attended by an international jury, the French tech scene and the French government ministers.</p>
<p><strong>October 2017 - Devoleum presented Station F of Paris, selected for the StartHer Awards 2017</strong></p>
<p><a href="https://www.facebook.com/MeetStartHer/videos/vb.303376065588/10155599438350589/">https://www.facebook.com/MeetStartHer/videos/vb.303376065588/10155599438350589/</a>? type=2&amp;theater
Devoleum was in the 10 selected among hundreds of European projects, to be presented at the Station F of Paris for the StartHer Awards 2017</p>
<p><strong>July 2017 - Press Wired about women in tech</strong></p>
<p><a href="https://www.wired.it/attualita/tech/2017/07/05/silicon-valley-donne-italia/">https://www.wired.it/attualita/tech/2017/07/05/silicon-valley-donne-italia/</a>
&ldquo;Non solo Silicon Valley, le donne del tech sono discriminate anche in Italia. Startuppare e imprenditrici italiane e londinesi raccontano le loro esperienze discriminatorie simili a quelle sotto accusa in Usa.&rdquo; Alessia Camera</p>
<p><strong>June 2016 - Press Startup Italia about Dammi la mano</strong></p>
<p><a href="http://startupitalia.eu/59457-20160627-digithon-startup-hackaton">http://startupitalia.eu/59457-20160627-digithon-startup-hackaton</a>
&ldquo;Il premio Tim, che darà l’accesso al programma di accelerazione TIM #Wcap per 12 settimane, prevede lezioni e moduli di lab e di mentorship, più un confronto one to one tra professionista e startup &quot; Stefania Leo</p>
<p><strong>June 2016 - Press Gazzetta del mezzogiorno italian newspaper about Dammi la Mano</strong></p>
<p><a href="http://www.dammilamano.it/assets/images/articolo-giornale-600x455-81.png">http://www.dammilamano.it/assets/images/articolo-giornale-600x455-81.png</a>
&ldquo;Progetti Innovativi innovativi al servizio del nostro futuro&rdquo;</p>
<p><strong>June 2016 - Press Il Sole 24 Ore italian newspaper about Dammi la Mano</strong></p>
<p><a href="http://www.ilsole24ore.com/art/impresa-e-territori/2016-06-26/piattaforme-online-studenti-e-">http://www.ilsole24ore.com/art/impresa-e-territori/2016-06-26/piattaforme-online-studenti-e-</a> app-non-perdersi-premiati-digithon-153006.shtml?uuid=ADtREYj
&ldquo;A “Dammi la mano” è andato il premio Tim che permette la partecipazione al programma di accelerazione TIM #Wcap con un percorso della durata di 12 settimane che prevede lezioni e moduli di lab e di mentorship e un confronto one to one tra professionista e startup.&rdquo; Andrea Biondi</p>
<p><strong>June 2016 - Press ANSA about Dammi la Mano</strong></p>
<p><a href="http://www.ansa.it/puglia/notizie/2016/06/26/vincitori-digithonbisogna-avere-tenacia_8cba16f6-">http://www.ansa.it/puglia/notizie/2016/06/26/vincitori-digithonbisogna-avere-tenacia_8cba16f6-</a> bc1d-46fc-bb11-6e3f434230db.html
&ldquo;A Dammi la mano, il progetto che consente di accompagnare ed essere accompagnati dai propri cari in tempo reale su Google Maps tramite l&rsquo;uso del proprio smartphone, va il Premio Tim che dà l&rsquo;accesso al programma di accelerazione TIM #Wcap&rdquo;</p>
<p><strong>June 2016 - TIM #Wcap Prize at Digithon 2016</strong></p>
<p><a href="https://www.youtube.com/watch?v=sfi4RUrIdcE">https://www.youtube.com/watch?v=sfi4RUrIdcE</a>
With our project &ldquo;Dammi la mano&rdquo; we won the Tim #Wcap Prize at Digithon 2016, we have been chosen from thousands of projects. Digithon 2016 was the first Hackathon in Italy, after our victory we received a lot of media coverage in national tv news, newspapers and online blogs.</p>
<p><strong>March 2013 - Winner of an overseas scholarship</strong></p>
<p>During my Master Degree in Psychology at Sapienza University of Rome, I won an overseas scholarship (3 months) for York University in Toronto, Canada, with my project on early autism diagnosis.</p>
]]></description></item><item><title>Develop a Soulbound NFT using Foundry and Slither</title><link>https://lorenzozaccagnini.github.io/posts/soulbound-nft/</link><pubDate>Tue, 16 Aug 2022 00:03:47 +0200</pubDate><guid>https://lorenzozaccagnini.github.io/posts/soulbound-nft/</guid><description><![CDATA[<p>Today we will develop a Soulbound NFT, an NFT that can be only minted and not traded or transferred, it is bounded to the first owner. We&rsquo;ll do it using foundry with hardhat integrated. The Github workflow will test <strong>(foundry solidity and hardhat typescript)</strong> the contracts and <a href="https://github.com/crytic/slither">uses Slither to statically analyze the code</a>, trying to find the most common vulnerabilities.</p>
<p>You can find all the code used in my repository <a href="https://github.com/LorenzoZaccagnini/Soulbound-NFT-foundry-slither">here</a></p>
<h2 id="1-install-foundry-and-create-the-project">1. Install Foundry and create the project</h2>
<h3 id="11-install-foundryhttpsgithubcomgakonstfoundry">1.1 Install <a href="https://github.com/gakonst/foundry">Foundry</a>.</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>curl -L https://foundry.paradigm.xyz | sh
</span></span></code></pre></div><h3 id="12-create-the-a-new-foundry-project">1.2 Create the a new foundry project</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>forge init soulbound-nft
</span></span></code></pre></div><h3 id="13-install-the-openzeppelin-library">1.3 Install the openzeppelin library</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>forge install openzeppelin/openzeppelin-contracts
</span></span></code></pre></div><h2 id="2-write-the-smart-contract">2. Write the smart contract</h2>
<p>Rename the smart contract in the <code>src</code> folder to <code>NFTToken.sol</code> or the name you want.</p>
<h3 id="21-use-a-pragma-solidity-directive-to-specify-the-compiler-version">2.1 Use a pragma solidity directive to specify the compiler version.</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#ff79c6">pragma solidity</span> <span style="color:#ff79c6">^</span><span style="color:#bd93f9">0</span>.<span style="color:#bd93f9">8</span>.<span style="color:#bd93f9">13</span>;
</span></span></code></pre></div><p>Use a version above 0.6.0 to avoid errors and previous vulns, like overflow and underflow. I prefer the latest stable version.</p>
<h3 id="22-import-the-openzeppelin-libraries">2.2 Import the openzeppelin libraries.</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts/token/ERC721/ERC721.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts/access/Ownable.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts/utils/Counters.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts/utils/Strings.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts/access/Ownable.sol&#34;</span>;
</span></span></code></pre></div><h3 id="23-inherit-from-the-erc721-and-ownable-contract">2.3 Inherit from the <code>ERC721</code> and <code>Ownable</code> contract.</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">contract</span> <span style="color:#50fa7b">NFTToken</span> <span style="color:#ff79c6">is</span> ERC721, Ownable {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Ownable is a library that allows the contract to be owned by a single address. Later we will implement the <code>onlyOwner</code> modifier to allow only the owner to call the functions.</p>
<h3 id="24-setup-a-counter-for-the-token-incremental-id">2.4. Setup a counter for the token incremental id.</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>    <span style="color:#ff79c6">using</span> Counters <span style="color:#ff79c6">for</span> Counters.Counter;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Counters.Counter <span style="color:#ff79c6">private</span> _tokenIdCounter;
</span></span></code></pre></div><p>Here we are making a new counter and naming it <code>_tokenIdCounter</code>, using the <code>safemath</code> library.</p>
<h3 id="25-setup-the-token-name-and-symbol">2.5 Setup the token name and symbol.</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">constructor</span>() ERC721(<span style="color:#f1fa8c">&#34;Soulbound&#34;</span>, <span style="color:#f1fa8c">&#34;SBNFT&#34;</span>) {}
</span></span></code></pre></div><p>If you feel confident you can even make a factory to create the token.</p>
<h3 id="26-write-the-safemint-function">2.6. Write the <code>safeMint</code> function.</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">safeMint</span>(<span style="color:#8be9fd">address</span> to) <span style="color:#ff79c6">public</span> onlyOwner {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">uint256</span> tokenId <span style="color:#ff79c6">=</span> _tokenIdCounter.current();
</span></span><span style="display:flex;"><span>        _tokenIdCounter.increment();
</span></span><span style="display:flex;"><span>        _safeMint(to, tokenId);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>This function is similar to the <code>mint</code> function in the <code>ERC721</code> contract, but it is protected by the <code>onlyOwner</code> modifier and uses the <code>_safeMint</code> function. An Internal function to safely mint a new token. Reverts if the given token ID already exists. If the target address is a contract, it must implement <code>onERC721Received</code>, which is called upon a safe transfer, and return the magic value <code>bytes4(keccak256...</code> otherwise, the transfer is reverted. <a href="https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#ERC721-_safeMint-address-uint256-bytes-">Source Openzeppelin documentation</a>.</p>
<h3 id="27-lets-implement-the-soulbound-features">2.7 Let&rsquo;s implement the soulbound features</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">modifier</span> <span style="color:#50fa7b">oneTransfer</span>(<span style="color:#8be9fd">address</span> <span style="color:#ff79c6">from</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">require</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">from</span> <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0x0000000000000000000000000000000000000000</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#f1fa8c">&#34;Soulbound nft can&#39;t be transferred&#34;</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">_</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">_beforeTokenTransfer</span>(
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">address</span> <span style="color:#ff79c6">from</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">address</span> to,
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd">uint256</span> tokenId
</span></span><span style="display:flex;"><span>) <span style="color:#ff79c6">internal</span> <span style="color:#ff79c6">override</span> oneTransfer(<span style="color:#ff79c6">from</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">super</span>._beforeTokenTransfer(<span style="color:#ff79c6">from</span>, to, tokenId);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>oneTransfer</code> modifier is used to prevent the transfer of the token to any other address, the 0x0000000000000000000000000000000000000000 address it&rsquo;s an impossible from address. We implement <code>oneTransfer</code> to the <code>_beforeTokenTransfer</code> function. The <code>_beforeTokenTransfer</code> overrides the <code>_beforeTokenTransfer</code> function in the <code>ERC721</code> contract, and it is called before the transfer, now we have a soulbound nft.</p>
<h3 id="28-recap-the-entire-contract">2.8 Recap the entire contract.</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#6272a4">// SPDX-License-Identifier: MIT
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pragma solidity</span> <span style="color:#ff79c6">^</span><span style="color:#bd93f9">0</span>.<span style="color:#bd93f9">8</span>.<span style="color:#bd93f9">13</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts/token/ERC721/ERC721.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts/access/Ownable.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts/utils/Counters.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts/utils/Strings.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@openzeppelin/contracts/access/Ownable.sol&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">contract</span> <span style="color:#50fa7b">NFTToken</span> <span style="color:#ff79c6">is</span> ERC721, Ownable {
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">using</span> Counters <span style="color:#ff79c6">for</span> Counters.Counter;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Counters.Counter <span style="color:#ff79c6">private</span> _tokenIdCounter;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">constructor</span>() ERC721(<span style="color:#f1fa8c">&#34;Soulbound&#34;</span>, <span style="color:#f1fa8c">&#34;SBNFT&#34;</span>) {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">modifier</span> <span style="color:#50fa7b">oneTransfer</span>(<span style="color:#8be9fd">address</span> <span style="color:#ff79c6">from</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">require</span>(
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">from</span> <span style="color:#ff79c6">==</span> <span style="color:#bd93f9">0x0000000000000000000000000000000000000000</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#f1fa8c">&#34;Soulbound nft can&#39;t be transferred&#34;</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">_</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">safeMint</span>(<span style="color:#8be9fd">address</span> to) <span style="color:#ff79c6">public</span> onlyOwner {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">uint256</span> tokenId <span style="color:#ff79c6">=</span> _tokenIdCounter.current();
</span></span><span style="display:flex;"><span>        _tokenIdCounter.increment();
</span></span><span style="display:flex;"><span>        _safeMint(to, tokenId);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">_beforeTokenTransfer</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">address</span> <span style="color:#ff79c6">from</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">address</span> to,
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd">uint256</span> tokenId
</span></span><span style="display:flex;"><span>    ) <span style="color:#ff79c6">internal</span> <span style="color:#ff79c6">override</span> oneTransfer(<span style="color:#ff79c6">from</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#8be9fd;font-style:italic">super</span>._beforeTokenTransfer(<span style="color:#ff79c6">from</span>, to, tokenId);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="3-write-foundry-tests-in-solidity">3. Write Foundry tests in solidity</h2>
<p>Foundry tests are a way to test the contracts in solidity, they are really fast compared to truffle or hardhat. Foundry is made in Rust, so it&rsquo;s blazing fast. Rename the test contract file in the <code>test</code> folder to <code>NFTToken.t.sol</code>, or the name you want that respects the naming convention <code>NAMECONTRACT.t.sol</code>.</p>
<h3 id="31-setup-the-test-environment">3.1 Setup the test environment.</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#6272a4">// SPDX-License-Identifier: UNLICENSED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">pragma solidity</span> <span style="color:#ff79c6">^</span><span style="color:#bd93f9">0</span>.<span style="color:#bd93f9">8</span>.<span style="color:#bd93f9">13</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;forge-std/Test.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;../src/NFTToken.sol&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">contract</span> <span style="color:#50fa7b">NFTTokenTest</span> <span style="color:#ff79c6">is</span> Test {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">using</span> stdStorage <span style="color:#ff79c6">for</span> StdStorage;
</span></span><span style="display:flex;"><span>    NFTToken <span style="color:#ff79c6">private</span> nft;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">setUp</span>() <span style="color:#ff79c6">public</span> {
</span></span><span style="display:flex;"><span>        nft <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> NFTToken();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I import the <code>Test</code> contract, and the <code>NFTToken</code> contract. NFTTokenTest is the name of the test contract. We are using the <code>stdStorage</code>, <a href="https://book.getfoundry.sh/reference/forge-std/std-storage">a library that makes manipulating storage easy</a>. <code>setUp()</code> is a function that is called before each test, and it initializes the contract.</p>
<h3 id="32-test-smart-contract-functions">3.2 Test Smart contract functions.</h3>
<p>Here I&rsquo;m testing the smart contract functions. The pattern is easy to understand, we test the function correct output and revert if it&rsquo;s not correct with the <code>vm.expectRevert()</code> function. The <code>vm.startPrank()</code> and <code>vm.stopPrank()</code> functions are used to simulate a user that is not the owner. By using solidity to write tests we can test the smart contract functions the closest possible to a real user or external contract.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-solidity" data-lang="solidity"><span style="display:flex;"><span><span style="color:#6272a4">// SPDX-License-Identifier: UNLICENSED
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">pragma solidity</span> <span style="color:#ff79c6">^</span><span style="color:#bd93f9">0</span>.<span style="color:#bd93f9">8</span>.<span style="color:#bd93f9">13</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;forge-std/Test.sol&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;../src/NFTToken.sol&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">contract</span> <span style="color:#50fa7b">NFTTokenTest</span> <span style="color:#ff79c6">is</span> Test {
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">using</span> stdStorage <span style="color:#ff79c6">for</span> StdStorage;
</span></span><span style="display:flex;"><span>NFTToken <span style="color:#ff79c6">private</span> nft;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">setUp</span>() <span style="color:#ff79c6">public</span> {
</span></span><span style="display:flex;"><span>        nft <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> NFTToken();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">testDeployment</span>() <span style="color:#ff79c6">public</span> {
</span></span><span style="display:flex;"><span>        assertEq(nft.<span style="color:#8be9fd;font-style:italic">name</span>(), <span style="color:#f1fa8c">&#34;Soulbound&#34;</span>);
</span></span><span style="display:flex;"><span>        assertEq(nft.symbol(), <span style="color:#f1fa8c">&#34;SBNFT&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">testOwner</span>() <span style="color:#ff79c6">public</span> {
</span></span><span style="display:flex;"><span>        assertEq(nft.owner(), <span style="color:#8be9fd">address</span>(<span style="color:#8be9fd;font-style:italic">this</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">testMintFailByNotOwnerUser</span>() <span style="color:#ff79c6">public</span> {
</span></span><span style="display:flex;"><span>        vm.expectRevert(<span style="color:#f1fa8c">&#34;Ownable: caller is not the owner&#34;</span>);
</span></span><span style="display:flex;"><span>        vm.startPrank(<span style="color:#8be9fd">address</span>(<span style="color:#bd93f9">2</span>));
</span></span><span style="display:flex;"><span>        nft.safeMint(<span style="color:#8be9fd">address</span>(<span style="color:#bd93f9">2</span>));
</span></span><span style="display:flex;"><span>        vm.stopPrank();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">testMint</span>() <span style="color:#ff79c6">public</span> {
</span></span><span style="display:flex;"><span>        nft.safeMint(<span style="color:#8be9fd">address</span>(<span style="color:#bd93f9">1</span>));
</span></span><span style="display:flex;"><span>        assertEq(nft.balanceOf(<span style="color:#8be9fd">address</span>(<span style="color:#bd93f9">1</span>)), <span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>        assertEq(nft.ownerOf(<span style="color:#bd93f9">0</span>), <span style="color:#8be9fd">address</span>(<span style="color:#bd93f9">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">testTransferFail</span>() <span style="color:#ff79c6">public</span> {
</span></span><span style="display:flex;"><span>        nft.safeMint(<span style="color:#8be9fd">address</span>(<span style="color:#bd93f9">2</span>));
</span></span><span style="display:flex;"><span>        vm.expectRevert(<span style="color:#f1fa8c">&#34;Soulbound nft can&#39;t be transferred&#34;</span>);
</span></span><span style="display:flex;"><span>        vm.startPrank(<span style="color:#8be9fd">address</span>(<span style="color:#bd93f9">2</span>));
</span></span><span style="display:flex;"><span>        nft.safeTransferFrom(<span style="color:#8be9fd">address</span>(<span style="color:#bd93f9">2</span>), <span style="color:#8be9fd">address</span>(<span style="color:#bd93f9">3</span>), <span style="color:#bd93f9">0</span>);
</span></span><span style="display:flex;"><span>        vm.stopPrank();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">testOwnerTransfer</span>() <span style="color:#ff79c6">public</span> {
</span></span><span style="display:flex;"><span>        assertEq(nft.owner(), <span style="color:#8be9fd">address</span>(<span style="color:#8be9fd;font-style:italic">this</span>));
</span></span><span style="display:flex;"><span>        nft.transferOwnership(<span style="color:#bd93f9">0x1111111111111111111111111111111111111111</span>);
</span></span><span style="display:flex;"><span>        assertEq(nft.owner(), <span style="color:#bd93f9">0x1111111111111111111111111111111111111111</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">function</span> <span style="color:#50fa7b">testOwnerTransferFail</span>() <span style="color:#ff79c6">public</span> {
</span></span><span style="display:flex;"><span>        assertEq(nft.owner(), <span style="color:#8be9fd">address</span>(<span style="color:#8be9fd;font-style:italic">this</span>));
</span></span><span style="display:flex;"><span>        vm.expectRevert(<span style="color:#f1fa8c">&#34;Ownable: caller is not the owner&#34;</span>);
</span></span><span style="display:flex;"><span>        vm.startPrank(<span style="color:#8be9fd">address</span>(<span style="color:#bd93f9">2</span>));
</span></span><span style="display:flex;"><span>        nft.transferOwnership(<span style="color:#bd93f9">0x1111111111111111111111111111111111111111</span>);
</span></span><span style="display:flex;"><span>        vm.stopPrank();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="33-test-contract-using-forge">3.3 Test contract using Forge</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>forge <span style="color:#8be9fd;font-style:italic">test</span>
</span></span></code></pre></div><p>All test cases should pass.</p>
<h2 id="4-integrating-foundry-with-hardhat">4. Integrating Foundry with Hardhat</h2>
<p>Hardhat by default expects libraries to be installed in <code>node_modules</code>, the default folder for all NodeJS dependencies. Foundry expects them to be in <code>lib</code>. Of course we can configure Foundry but not easily to the directory structure of <code>node_modules</code>. <a href="https://book.getfoundry.sh/config/hardhat">Documentation</a> has more information.</p>
<h3 id="41-install-hardhat">4.1 Install hardhat</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>yarn init
</span></span><span style="display:flex;"><span>yarn add hardhat hardhat-preprocessor
</span></span><span style="display:flex;"><span>npx hardhat
</span></span><span style="display:flex;"><span>forge remappings &gt; remappings.txt
</span></span></code></pre></div><p>You will need to re-run forge remappings everytime you modify libraries in Foundry. Now your <code>remappings.txt</code> should look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ds-test/<span style="color:#ff79c6">=</span>lib/solmate/lib/ds-test/src/
</span></span><span style="display:flex;"><span>forge-std/<span style="color:#ff79c6">=</span>lib/forge-std/src/
</span></span><span style="display:flex;"><span>openzeppelin-contracts/contracts/<span style="color:#ff79c6">=</span>lib/openzeppelin-contracts/contracts/
</span></span><span style="display:flex;"><span>solmate/<span style="color:#ff79c6">=</span>lib/solmate/src/
</span></span></code></pre></div><h3 id="42-configure-hardhat">4.2 Configure hardhat</h3>
<p>Edit <code>hardhat.config.ts</code> to look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> fs <span style="color:#ff79c6">from</span> <span style="color:#f1fa8c">&#34;fs&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@nomicfoundation/hardhat-chai-matchers&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;@typechain/hardhat&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> <span style="color:#f1fa8c">&#34;hardhat-preprocessor&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> { HardhatUserConfig, task } <span style="color:#ff79c6">from</span> <span style="color:#f1fa8c">&#34;hardhat/config&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">function</span> getRemappings() {
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">return</span> fs
</span></span><span style="display:flex;"><span>    .readFileSync(<span style="color:#f1fa8c">&#34;remappings.txt&#34;</span>, <span style="color:#f1fa8c">&#34;utf8&#34;</span>)
</span></span><span style="display:flex;"><span>    .split(<span style="color:#f1fa8c">&#34;\n&#34;</span>)
</span></span><span style="display:flex;"><span>    .filter(<span style="color:#8be9fd;font-style:italic">Boolean</span>)
</span></span><span style="display:flex;"><span>    .map((line) <span style="color:#ff79c6">=&gt;</span> line.trim().split(<span style="color:#f1fa8c">&#34;=&#34;</span>));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">const</span> config: <span style="color:#8be9fd">HardhatUserConfig</span> <span style="color:#ff79c6">=</span> {
</span></span><span style="display:flex;"><span>  solidity<span style="color:#ff79c6">:</span> {
</span></span><span style="display:flex;"><span>    version<span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;0.8.13&#34;</span>,
</span></span><span style="display:flex;"><span>    settings<span style="color:#ff79c6">:</span> {
</span></span><span style="display:flex;"><span>      optimizer<span style="color:#ff79c6">:</span> {
</span></span><span style="display:flex;"><span>        enabled: <span style="color:#8be9fd">true</span>,
</span></span><span style="display:flex;"><span>        runs: <span style="color:#8be9fd">200</span>,
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>    },
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>  paths<span style="color:#ff79c6">:</span> {
</span></span><span style="display:flex;"><span>    sources<span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;./src&#34;</span>, <span style="color:#6272a4">// Use ./src rather than ./contracts as Hardhat expects
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    cache<span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;./cache_hardhat&#34;</span>, <span style="color:#6272a4">// Use a different cache for Hardhat than Foundry
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  },
</span></span><span style="display:flex;"><span>  <span style="color:#6272a4">// This fully resolves paths for imports in the ./lib directory for Hardhat
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>  preprocess<span style="color:#ff79c6">:</span> {
</span></span><span style="display:flex;"><span>    eachLine<span style="color:#ff79c6">:</span> (hre) <span style="color:#ff79c6">=&gt;</span> ({
</span></span><span style="display:flex;"><span>      transform<span style="color:#ff79c6">:</span> (line: <span style="color:#8be9fd">string</span>) <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">if</span> (line.match(<span style="color:#f1fa8c">/^\s*import /i</span>)) {
</span></span><span style="display:flex;"><span>          getRemappings().forEach(([find, replace]) <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> (line.match(find)) {
</span></span><span style="display:flex;"><span>              line <span style="color:#ff79c6">=</span> line.replace(find, replace);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>          });
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span> line;
</span></span><span style="display:flex;"><span>      },
</span></span><span style="display:flex;"><span>    }),
</span></span><span style="display:flex;"><span>  },
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">export</span> <span style="color:#ff79c6">default</span> config;
</span></span></code></pre></div><h2 id="5-write-hardhat-tests-in-typescript">5. Write Hardhat tests in typescript</h2>
<h3 id="51-create-test-contract">5.1 Create test contract</h3>
<p>Create the contract in the <code>test</code> folder using this name convention <code>nfttoken.test.ts</code>.</p>
<h3 id="52-write-test-hardhat-file">5.2 Write test hardhat file</h3>
<p>Here we do the same as the Foundry tests, but we use the hardhat <code>expect</code> and the <code>to.be.revertedWith</code> function. If the revertedWith is not recognized install the <code>&quot;@nomicfoundation/hardhat-chai-matchers</code> package. More info <a href="https://hardhat.org/hardhat-chai-matchers/docs/overview">here</a> about this.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-typescript" data-lang="typescript"><span style="display:flex;"><span><span style="color:#ff79c6">import</span> { SignerWithAddress } <span style="color:#ff79c6">from</span> <span style="color:#f1fa8c">&#34;@nomiclabs/hardhat-ethers/signers&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> { expect } <span style="color:#ff79c6">from</span> <span style="color:#f1fa8c">&#34;chai&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> { ethers } <span style="color:#ff79c6">from</span> <span style="color:#f1fa8c">&#34;hardhat&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">import</span> { NFTToken } <span style="color:#ff79c6">from</span> <span style="color:#f1fa8c">&#34;../typechain-types&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>describe(<span style="color:#f1fa8c">&#34;NFTToken&#34;</span>, <span style="color:#8be9fd;font-style:italic">function</span> () {
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">let</span> owner: <span style="color:#8be9fd">SignerWithAddress</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">let</span> addr1: <span style="color:#8be9fd">SignerWithAddress</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">let</span> addr2: <span style="color:#8be9fd">SignerWithAddress</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#8be9fd;font-style:italic">let</span> nft: <span style="color:#8be9fd">NFTToken</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  beforeEach(<span style="color:#ff79c6">async</span> <span style="color:#8be9fd;font-style:italic">function</span> () {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">const</span> Nft <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> ethers.getContractFactory(<span style="color:#f1fa8c">&#34;NFTToken&#34;</span>);
</span></span><span style="display:flex;"><span>    nft <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> Nft.deploy();
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> nft.deployed();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    [owner, addr1, addr2] <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">await</span> ethers.getSigners();
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it(<span style="color:#f1fa8c">&#34;Should return name and symbol&#34;</span>, <span style="color:#ff79c6">async</span> <span style="color:#8be9fd;font-style:italic">function</span> () {
</span></span><span style="display:flex;"><span>    expect(<span style="color:#ff79c6">await</span> nft.name()).to.equal(<span style="color:#f1fa8c">&#34;Soulbound&#34;</span>);
</span></span><span style="display:flex;"><span>    expect(<span style="color:#ff79c6">await</span> nft.<span style="color:#8be9fd">symbol</span>()).to.equal(<span style="color:#f1fa8c">&#34;SBNFT&#34;</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it(<span style="color:#f1fa8c">&#34;Should set the first account as the owner&#34;</span>, <span style="color:#ff79c6">async</span> () <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>    expect(<span style="color:#ff79c6">await</span> nft.owner()).to.equal(owner.address);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it(<span style="color:#f1fa8c">&#34;Should NOT mint a token as NOT the Owner&#34;</span>, <span style="color:#ff79c6">async</span> () <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> expect(nft.connect(addr1).safeMint(addr1.address)).to.be.revertedWith(
</span></span><span style="display:flex;"><span>      <span style="color:#f1fa8c">&#34;Ownable: caller is not the owner&#34;</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it(<span style="color:#f1fa8c">&#34;Should mint a token as the Owner&#34;</span>, <span style="color:#ff79c6">async</span> () <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> nft.safeMint(addr1.address);
</span></span><span style="display:flex;"><span>    expect(<span style="color:#ff79c6">await</span> nft.ownerOf(<span style="color:#bd93f9">0</span>)).to.equal(addr1.address);
</span></span><span style="display:flex;"><span>    expect(<span style="color:#ff79c6">await</span> nft.balanceOf(addr1.address)).to.equal(<span style="color:#bd93f9">1</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it(<span style="color:#f1fa8c">&#34;Should not be able to transfer soulbound token&#34;</span>, <span style="color:#ff79c6">async</span> () <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> nft.safeMint(owner.address);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">//OVERLOADED TRANSFER function
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">await</span> expect(
</span></span><span style="display:flex;"><span>      nft[<span style="color:#f1fa8c">&#34;safeTransferFrom(address,address,uint256)&#34;</span>](
</span></span><span style="display:flex;"><span>        owner.address,
</span></span><span style="display:flex;"><span>        addr2.address,
</span></span><span style="display:flex;"><span>        <span style="color:#bd93f9">0</span>
</span></span><span style="display:flex;"><span>      )
</span></span><span style="display:flex;"><span>    ).to.be.revertedWith(<span style="color:#f1fa8c">&#34;Soulbound nft can&#39;t be transferred&#34;</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it(<span style="color:#f1fa8c">&#34;Should NOT transfer the contract NON owner to the new owner&#34;</span>, <span style="color:#ff79c6">async</span> () <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> expect(
</span></span><span style="display:flex;"><span>      nft.connect(addr1).transferOwnership(addr2.address)
</span></span><span style="display:flex;"><span>    ).to.be.revertedWith(<span style="color:#f1fa8c">&#34;Ownable: caller is not the owner&#34;</span>);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  it(<span style="color:#f1fa8c">&#34;Should transfer the contract owner to the new owner&#34;</span>, <span style="color:#ff79c6">async</span> () <span style="color:#ff79c6">=&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">await</span> nft.transferOwnership(addr2.address);
</span></span><span style="display:flex;"><span>    expect(<span style="color:#ff79c6">await</span> nft.owner()).to.equal(addr2.address);
</span></span><span style="display:flex;"><span>  });
</span></span><span style="display:flex;"><span>});
</span></span></code></pre></div><p>Different addresses are simulated by using the <code>connect</code> function. The <code>beforeEach</code> function is used to set up the contract and the <code>it</code> function is used to test the contract.</p>
<h3 id="53-hardhat-vs-forge-vs-truffle">5.3 Hardhat VS Forge VS Truffle</h3>
<p>I prefer Forge, is faster and closer to the real environment. Hardhat right now is optional, but I would recommend using it as an alternative. Truffle is now obsolete and will be less and less used in the future.</p>
<h2 id="6-create-a-github-workflow-with-tests-and-slither-audit">6. Create a Github workflow with tests and slither audit</h2>
<h3 id="61-create-a-github-workflow">6.1 Create a Github workflow</h3>
<p>Create a file named <code>.github/workflows/audit.yml</code> and put this content:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ff79c6">name</span>: Audit
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">on</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">push</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">branches</span>: [main, develop]
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">pull_request</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">branches</span>: [main, develop]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">jobs</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">build</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">runs-on</span>: ubuntu-latest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">steps</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">uses</span>: actions/checkout@v3
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">submodules</span>: recursive
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: Install Foundry
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">uses</span>: foundry-rs/foundry-toolchain@v1
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">version</span>: nightly
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: Run Forge build
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">run</span>: |<span style="color:#f1fa8c">
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          forge --version
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          forge build --sizes</span>          
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">id</span>: build
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: Run Forge tests
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">run</span>: |<span style="color:#f1fa8c">
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          </span>          forge test -vvv
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">id</span>: forge-test
</span></span></code></pre></div><p>This will install Foundry and run the Forge build and tests.
<img src="/images/post_pics/foundry_tests.jpg" alt=""></p>
<h3 id="62-optional-hardat-tests">6.2 Optional Hardat tests</h3>
<p>If you want to use hardhat add a step that uses <code>yarn</code> to instal the packages and run the command <code>npx hardhat test</code>, this will run the tests with Hardhat.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: Setup NodeJS 14
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">uses</span>: actions/setup-node@v2
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">with</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">node-version</span>: <span style="color:#f1fa8c">&#34;14&#34;</span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: Show NodeJS version
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">run</span>: npm --version
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: Install Dependencies
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">run</span>: npm install
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: Run hardhat Test
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">run</span>: npx hardhat compile; npx hardhat test
</span></span></code></pre></div><p>Should look like this:
<img src="/images/post_pics/hardhat_tests.jpg" alt=""></p>
<h3 id="63-add-slither-audit">6.3 Add slither audit</h3>
<p>Slither is a Solidity static analysis framework written in Python 3. It runs a suite of vulnerability detectors, prints visual information about contract details, and provides an API to easily write custom analyses. Slither enables developers to find vulnerabilities, enhance their code comprehension, and quickly prototype custom analyses. <a href="https://github.com/crytic/slither">Source</a></p>
<p>We can even add slither manually, but I prefer to use <code>slither-action</code> command. It&rsquo;s a great tool because will push slither&rsquo;s alerts to the Security tab of the Github project, easing the triaging of findings and improving the continious integration flow.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: slither-action
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">uses</span>: crytic/slither-action@v0.1.1
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">continue-on-error</span>: <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">id</span>: slither
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">with</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">sarif</span>: results.sarif
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>- <span style="color:#ff79c6">name</span>: Upload SARIF file
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">uses</span>: github/codeql-action/upload-sarif@v2
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">with</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">sarif_file</span>: ${{ steps.slither.outputs.sarif }}
</span></span></code></pre></div><p>If everything is correct you will this result in the Security tab of the Github project:
<img src="/images/post_pics/slither_results.jpg" alt=""></p>
<h3 id="64-recap">6.4 Recap</h3>
<p>They yaml file is used to create a Github workflow that will run the tests and slither audit. Should look like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#ff79c6">name</span>: Hardhat Build
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">on</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">push</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">branches</span>: [main, develop]
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">pull_request</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">branches</span>: [main, develop]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff79c6">jobs</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#ff79c6">build</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">runs-on</span>: ubuntu-latest
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff79c6">steps</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">uses</span>: actions/checkout@v3
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">submodules</span>: recursive
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: Install Foundry
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">uses</span>: foundry-rs/foundry-toolchain@v1
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">version</span>: nightly
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: Run Forge build
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">run</span>: |<span style="color:#f1fa8c">
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          forge --version
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          forge build --sizes</span>          
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">id</span>: build
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: Run Forge tests
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">run</span>: |<span style="color:#f1fa8c">
</span></span></span><span style="display:flex;"><span><span style="color:#f1fa8c">          </span>          forge test -vvv
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">id</span>: forge-test
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: Setup NodeJS 14
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">uses</span>: actions/setup-node@v2
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">node-version</span>: <span style="color:#f1fa8c">&#34;14&#34;</span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: Show NodeJS version
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">run</span>: npm --version
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: Install Dependencies
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">run</span>: yarn
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: Run hardhat Test
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">run</span>: npx hardhat compile; npx hardhat test
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: slither-action
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">uses</span>: crytic/slither-action@v0.1.1
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">continue-on-error</span>: <span style="color:#ff79c6">true</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">id</span>: slither
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">sarif</span>: results.sarif
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      - <span style="color:#ff79c6">name</span>: Upload SARIF file
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">uses</span>: github/codeql-action/upload-sarif@v2
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">with</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#ff79c6">sarif_file</span>: ${{ steps.slither.outputs.sarif }}
</span></span></code></pre></div>]]></description><media:thumbnail url="https://lorenzozaccagnini.github.io/images/post_pics/soulbound-nft-cover.jpg"/></item></channel></rss>